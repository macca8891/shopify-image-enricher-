<!DOCTYPE html>
<html>
<head>
    <title>Shopify Shipping Rate Calculator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 10px;
        }
        button {
            background: #008060;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #004c3f;
        }
        button.secondary {
            background: #f1f2f3;
            color: #333;
            border: 1px solid #ccc;
        }
        button.secondary:hover {
            background: #e1e2e3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        th[onclick] {
            position: relative;
        }
        th[onclick]:hover {
            background-color: #e9ecef;
        }
        .sort-indicator {
            font-size: 10px;
            margin-left: 5px;
            color: #999;
        }
        .sort-indicator.asc::after {
            content: ' ‚ñ≤';
            color: #008060;
        }
        .sort-indicator.desc::after {
            content: ' ‚ñº';
            color: #008060;
        }
        #ratesTable tbody tr {
            transition: background-color 0.2s;
        }
        #ratesTable tbody tr:hover {
            background-color: #f8f9fa;
        }
        #ratesTable tbody tr:nth-child(even) {
            background-color: #fafafa;
        }
        #ratesTable tbody tr:nth-child(even):hover {
            background-color: #f0f0f0;
        }
        img.product-thumb {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
        }
        .status-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .badge-pending { background: #fff3cd; color: #856404; }
        .badge-success { background: #d4edda; color: #155724; }
        .badge-error { background: #f8d7da; color: #721c24; }
        .badge-info { background: #cce5ff; color: #004085; }

        .log-container {
            margin-top: 20px;
            background: #333;
            color: #0f0;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
        }

        /* Modal Styles */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.5); 
        }
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; 
            padding: 20px;
            border: 1px solid #888;
            width: 500px;
            border-radius: 8px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .address-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .address-row select,
        .address-row input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .address-row .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .address-row .remove-btn:hover {
            background: #c82333;
        }
        .shipping-details-row {
            display: none;
            background: #f8f9fa;
        }
        .shipping-details-row.expanded {
            display: table-row;
        }
        .shipping-details-cell {
            padding: 15px;
            background: white;
            border-left: 3px solid #007cba;
        }
        .shipping-location {
            margin-bottom: 15px;
            padding: 10px;
            background: #f0f8ff;
            border-radius: 4px;
            border-left: 3px solid #007cba;
        }
        .shipping-location:last-child {
            margin-bottom: 0;
        }
        .shipping-location-header {
            font-weight: bold;
            color: #007cba;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .shipping-rate-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e0e0e0;
        }
        .shipping-rate-item:last-child {
            border-bottom: none;
        }
        .rate-label {
            color: #666;
            font-size: 12px;
        }
        .rate-value {
            font-weight: bold;
            color: #333;
        }
        .toggle-details-btn {
            background: #007cba;
            color: white;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 5px;
        }
        .toggle-details-btn:hover {
            background: #005a8a;
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #ddd;
            margin-bottom: 20px;
            background: white;
            padding: 0 20px;
            border-radius: 8px 8px 0 0;
        }
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 16px;
            font-weight: bold;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .tab:hover {
            color: #008060;
            background: #f5f5f5;
        }
        .tab.active {
            color: #008060;
            border-bottom-color: #008060;
            background: #f5f5f5;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1>üì¶ Shipping Rate Calculator</h1>
            <p>Calculate shipping codes via BuckyDrop and sync to Shopify weights</p>
        </div>
        <div>
            <span id="shopName">Connecting...</span>
            <button onclick="showConfigModal()" class="secondary" style="margin-left: 10px; font-size: 12px;">‚öôÔ∏è Config</button>
        </div>
    </div>

    <div class="controls">
        <!-- Metafield Import Section -->
        <div style="background: #f0f8ff; border: 2px solid #007cba; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div>
                    <h3 style="margin: 0; color: #007cba; font-size: 16px;">üìä Product & Metafield Import</h3>
                    <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">Import products from Shopify with dimensions (largest_diameter_raw, height_raw)</p>
                </div>
                <div style="text-align: right;">
                    <div id="metafieldStats" style="font-size: 11px; color: #666; margin-bottom: 5px;">Checking metafield status...</div>
                    <button onclick="importFromShopify()" id="importBtn" class="secondary" style="background-color: #007cba; color: white; border: none; font-weight: bold; padding: 10px 20px;">
                        ‚¨áÔ∏è Import Products & Metafields
                    </button>
                </div>
            </div>
            <div id="importProgress" style="display: none; margin-top: 10px; padding: 10px; background: white; border-radius: 4px; font-size: 12px;">
                <div style="margin-bottom: 5px;">‚è≥ Importing products and metafields from Shopify...</div>
                <div id="importStatus" style="color: #007cba;"></div>
            </div>
        </div>
        
        <div class="control-row">
            <button onclick="loadProducts()" class="secondary">üîÑ Reload from DB</button>
            <input type="text" id="searchInput" placeholder="üîç Search products (title, SKU, vendor)..." 
                   style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; min-width: 300px; margin-left: 10px;"
                   onkeyup="handleSearchInput(event)">
            <button onclick="clearSearch()" class="secondary" style="margin-left: 5px; padding: 8px 12px;">Clear</button>
            <select id="statusFilter" onchange="filterProducts()" style="margin-left: 10px;">
                <option value="all">All Statuses</option>
                <option value="active">Active</option>
                <option value="draft">Draft</option>
                <option value="archived">Archived</option>
            </select>
            <select id="processedFilter" onchange="filterProducts()" style="margin-left: 10px;">
                <option value="all">All Products</option>
                <option value="processed">Processed Only</option>
                <option value="unprocessed">Unprocessed Only</option>
                <option value="failed">Failed/No Results</option>
            </select>
            <span id="stats">0 products loaded</span>
        </div>
        <div style="margin-top: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <label style="font-weight: bold;">üìç Shipping Addresses (Multiple Locations):</label>
                <button onclick="addAddressRow()" class="secondary" style="padding: 5px 15px; font-size: 12px;">+ Add Address</button>
            </div>
            <div id="addressesContainer" style="background: #f9f9f9; padding: 15px; border-radius: 4px; margin-bottom: 10px;">
                <!-- Address rows will be dynamically added here -->
            </div>
            <div style="margin-top: 10px;">
                <button onclick="calculateSelected()">üßÆ Calculate Shipping (Selected)</button>
                <button onclick="calculateAllProducts()" style="background: #28a745; margin-left: 10px;">üöÄ Calculate All Products</button>
                <button onclick="recalculateFailedRates()" style="margin-left: 10px; background: #17a2b8; color: white;">üîÑ Recalculate Failed Rates</button>
                <button onclick="assignCodes()" style="margin-left: 10px; background: #ff6b35;">üî¢ Assign Codes</button>
            </div>
            
            <!-- Carrier Calculated Shipping Section -->
            <div style="margin-top: 20px; padding: 15px; background: #e8f4f8; border-radius: 6px; border-left: 4px solid #17a2b8;">
                <h3 style="margin: 0 0 10px 0; color: #17a2b8;">üöö Carrier Calculated Shipping (CCS)</h3>
                <p style="margin: 0 0 15px 0; color: #666; font-size: 14px;">
                    Enable BuckyDrop rates to show at checkout automatically. Requires Shopify Grow plan or higher.
                </p>
                <div id="carrierServiceStatus" style="margin-bottom: 10px;">
                    <span style="color: #666;">Status: </span>
                    <span id="carrierServiceStatusText" style="font-weight: bold;">Checking...</span>
                </div>
                <button onclick="registerCarrierService()" id="registerCarrierBtn" style="background: #17a2b8; color: white; margin-right: 10px;">‚úÖ Enable Carrier Service</button>
                <button onclick="unregisterCarrierService()" id="unregisterCarrierBtn" style="background: #dc3545; color: white; display: none;">‚ùå Disable Carrier Service</button>
                <button onclick="checkCarrierServiceStatus()" class="secondary" style="margin-left: 10px;">üîÑ Refresh Status</button>
                <button onclick="listCarrierServices()" class="secondary" style="margin-left: 10px;">üîç List All Services</button>
            </div>
            
            <div class="control-row" style="margin-top: 20px;">
                <button onclick="updateWeights()" style="margin-left: 10px; background: #6b35ff;">‚öñÔ∏è Update Weights</button>
                <button onclick="syncSelected()" style="margin-left: 10px;">üíæ Sync to Shopify (Selected)</button>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="unprocessSelected()" style="background: #ffc107; color: #000;">‚Ü©Ô∏è Unprocess (Selected)</button>
                <button onclick="deleteRatesSelected()" style="margin-left: 10px; background: #dc3545; color: white;">üóëÔ∏è Delete Shipping Rates (Selected)</button>
            </div>
        </div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
        <button class="tab active" onclick="switchTab('products')">üì¶ Products</button>
        <button class="tab" onclick="switchTab('rates')">üìä Shipping Rates</button>
    </div>

    <!-- Products Tab -->
    <div id="productsTab" class="tab-content active">
    <table id="productsTable">
        <thead>
            <tr>
                <th>
                    <input type="checkbox" id="selectAll" onclick="toggleSelectAll()">
                    <button onclick="selectAllProducts()" class="secondary" style="margin-left: 5px; padding: 4px 8px; font-size: 11px;" title="Select all products matching current filter">Select All</button>
                </th>
                <th>Image</th>
                <th onclick="sortTable('title')" style="cursor: pointer; user-select: none;" title="Click to sort by title">
                    Title <span id="sort-title" class="sort-indicator"></span>
                </th>
                <th onclick="sortTable('status')" style="cursor: pointer; user-select: none;" title="Click to sort by status">
                    Status <span id="sort-status" class="sort-indicator"></span>
                </th>
                <th onclick="sortTable('weight')" style="cursor: pointer; user-select: none;" title="Click to sort by weight">
                    Weight (kg) <span id="sort-weight" class="sort-indicator"></span>
                </th>
                <th onclick="sortTable('length')" style="cursor: pointer; user-select: none;" title="Click to sort by length">
                    Length (cm) <span id="sort-length" class="sort-indicator"></span>
                </th>
                <th onclick="sortTable('height')" style="cursor: pointer; user-select: none;" title="Click to sort by height">
                    Height (cm) <span id="sort-height" class="sort-indicator"></span>
                </th>
                <th onclick="sortTable('width')" style="cursor: pointer; user-select: none;" title="Click to sort by width">
                    Width (cm) <span id="sort-width" class="sort-indicator"></span>
                </th>
                <th onclick="sortTable('code')" style="cursor: pointer; user-select: none;" title="Click to sort by code">
                    Code <span id="sort-code" class="sort-indicator"></span>
                </th>
                <th onclick="sortTable('cost')" style="cursor: pointer; user-select: none;" title="Click to sort by shipping cost">
                    Shipping Cost (USD)<br><small>Cheap / Express</small> <span id="sort-cost" class="sort-indicator"></span>
                </th>
                <th>Carrier<br><small>Cheap / Express</small></th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody id="tableBody">
            <tr><td colspan="12" style="text-align:center">Loading...</td></tr>
        </tbody>
    </table>
    </div>

    <!-- Shipping Rates Tab -->
    <div id="ratesTab" class="tab-content">
        <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0;">üìä Shipping Rates</h2>
                <div>
                    <button onclick="loadShippingRates()" class="secondary">üîÑ Refresh</button>
                    <button onclick="exportToCSV()" style="background: #28a745; margin-left: 10px;">üì• Export to CSV</button>
                </div>
            </div>
            
            <!-- Search and Filters -->
            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                <div>
                    <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #333;">üîç Search</label>
                    <input type="text" id="ratesSearch" placeholder="Search by country, code, service..." 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                           oninput="filterRatesTable()">
                </div>
                <div>
                    <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #333;">üåç Country</label>
                    <select id="ratesCountryFilter" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                            onchange="filterRatesTable()">
                        <option value="">All Countries</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #333;">üî¢ Code</label>
                    <input type="text" id="ratesCodeFilter" placeholder="Filter by code..." 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                           oninput="filterRatesTable()">
                </div>
                <div>
                    <label style="display: block; margin-bottom: 5px; font-weight: 500; color: #333;">üì¶ Service Type</label>
                    <select id="ratesServiceFilter" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                            onchange="filterRatesTable()">
                        <option value="">All Services</option>
                        <option value="standard">Standard Only</option>
                        <option value="express">Express Only</option>
                        <option value="both">Both</option>
                    </select>
                </div>
            </div>
            
            <div id="ratesStats" style="color: #666; margin-bottom: 10px;">Loading rates...</div>
        </div>
        <table id="ratesTable" style="display: none; width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: #f8f9fa;">
                    <th onclick="sortRatesTable('country')" style="cursor: pointer; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; user-select: none;">
                        Country <span class="sort-indicator" id="sort-country"></span>
                    </th>
                    <th onclick="sortRatesTable('province')" style="cursor: pointer; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; user-select: none;">
                        Province <span class="sort-indicator" id="sort-province"></span>
                    </th>
                    <th onclick="sortRatesTable('postcode')" style="cursor: pointer; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; user-select: none;">
                        Postcode <span class="sort-indicator" id="sort-postcode"></span>
                    </th>
                    <th onclick="sortRatesTable('service')" style="cursor: pointer; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; user-select: none;">
                        Service <span class="sort-indicator" id="sort-service"></span>
                    </th>
                    <th onclick="sortRatesTable('days')" style="cursor: pointer; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; user-select: none;">
                        Days <span class="sort-indicator" id="sort-days"></span>
                    </th>
                    <th onclick="sortRatesTable('price')" style="cursor: pointer; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; user-select: none;">
                        Price (USD) <span class="sort-indicator" id="sort-price"></span>
                    </th>
                    <th onclick="sortRatesTable('code')" style="cursor: pointer; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; user-select: none;">
                        Code <span class="sort-indicator" id="sort-code"></span>
                    </th>
                </tr>
            </thead>
            <tbody id="ratesTableBody">
                <tr><td colspan="7" style="text-align:center">Loading...</td></tr>
            </tbody>
        </table>
        <div id="ratesEmpty" style="display: none; text-align: center; padding: 40px; background: white; border-radius: 8px;">
            <p style="font-size: 18px; color: #666;">No shipping rates found.</p>
            <p style="color: #999; margin-top: 10px;">Calculate shipping rates first, then assign codes.</p>
        </div>
    </div>

    <div class="log-container" id="log"></div>

    <!-- Configuration Modal -->
    <div id="configModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeConfigModal()">&times;</span>
            <h2>‚öôÔ∏è Connect to Shopify</h2>
            <p>Enter your Shopify credentials to connect directly.</p>
            
            <div class="form-group">
                <label>Shop Domain (e.g. my-store.myshopify.com)</label>
                <input type="text" id="configShop" placeholder="my-store.myshopify.com">
            </div>
            
            <div class="form-group">
                <label>Admin API Access Token (shpat_...)</label>
                <input type="password" id="configToken" placeholder="shpat_xxxxxxxxxxxxxxxx">
            </div>
            
            <button onclick="saveConfig()">Connect Shop</button>
            <p id="configMsg" style="margin-top: 10px; font-weight: bold;"></p>
        </div>
    </div>

    <script>
        let allProducts = [];
        let calculatedData = {}; // Map productId -> { code, cost, etc }
        let addressResults = {}; // Map productId -> { addressId -> result }
        // Load shop domain from localStorage or use default
        let SHOP_DOMAIN = localStorage.getItem('shopDomain') || "spare-part-mart.myshopify.com";
        let currentPage = 1;
        let currentStatus = 'all';
        let totalProducts = 0;
        let totalPages = 1;
        let addressCounter = 0; // Unique ID for each address row
        
        // Wake Lock API to prevent screen sleep during calculations
        let wakeLock = null;
        let noSleepVideo = null;
        
        // Acquire wake lock to prevent screen sleep
        async function acquireWakeLock() {
            try {
                // Try Wake Lock API first (modern browsers)
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    log('üîí Wake lock acquired (screen will stay awake)');
                    wakeLock.addEventListener('release', () => {
                        log('‚ö†Ô∏è Wake lock released');
                    });
                    return true;
                }
            } catch (err) {
                log(`‚ö†Ô∏è Wake Lock API not available: ${err.message}`);
            }
            
            // Fallback: Create hidden video element to prevent sleep
            try {
                if (!noSleepVideo) {
                    noSleepVideo = document.createElement('video');
                    noSleepVideo.setAttribute('playsinline', '');
                    noSleepVideo.setAttribute('autoplay', '');
                    noSleepVideo.setAttribute('muted', '');
                    noSleepVideo.setAttribute('loop', '');
                    noSleepVideo.style.display = 'none';
                    noSleepVideo.style.width = '1px';
                    noSleepVideo.style.height = '1px';
                    noSleepVideo.style.position = 'absolute';
                    noSleepVideo.style.opacity = '0';
                    
                    // Create a minimal video blob (1px x 1px, 1 frame)
                    const canvas = document.createElement('canvas');
                    canvas.width = 1;
                    canvas.height = 1;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, 1, 1);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            noSleepVideo.src = URL.createObjectURL(blob);
                            document.body.appendChild(noSleepVideo);
                            noSleepVideo.play().catch(() => {
                                // Ignore play errors
                            });
                            log('üîí Fallback no-sleep method activated');
                        }
                    });
                } else {
                    noSleepVideo.play().catch(() => {});
                }
                return true;
            } catch (err) {
                log(`‚ö†Ô∏è Could not prevent sleep: ${err.message}`);
                return false;
            }
        }
        
        // Release wake lock
        async function releaseWakeLock() {
            try {
                if (wakeLock) {
                    await wakeLock.release();
                    wakeLock = null;
                    log('üîì Wake lock released');
                }
            } catch (err) {
                // Ignore errors
            }
            
            // Stop fallback video
            if (noSleepVideo) {
                try {
                    noSleepVideo.pause();
                    noSleepVideo.src = '';
                    if (noSleepVideo.parentNode) {
                        noSleepVideo.parentNode.removeChild(noSleepVideo);
                    }
                    noSleepVideo = null;
                } catch (err) {
                    // Ignore errors
                }
            }
        }

        function log(msg) {
            console.log(msg); // Also log to console
            const div = document.getElementById('log');
            div.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            div.scrollTop = div.scrollHeight;
        }

        // Capital city addresses for each country
        function getCapitalCityAddress(country) {
            const capitalAddresses = {
                'Australia': { province: 'ACT', postcode: '2600', address: 'Parliament House, Canberra' },
                'United States': { province: 'District of Columbia', postcode: '20001', address: '1600 Pennsylvania Avenue NW, Washington' },
                'Canada': { province: 'Ontario', postcode: 'K1A 0A6', address: 'Parliament Hill, Ottawa' },
                'New Zealand': { province: 'Wellington', postcode: '6011', address: 'Parliament Buildings, Wellington' },
                'Indonesia': { province: 'Jakarta', postcode: '10110', address: 'Merdeka Square, Jakarta' },
                'India': { province: 'Delhi', postcode: '110001', address: 'Parliament House, New Delhi' },
                'United Kingdom': { province: 'England', postcode: 'SW1A 1AA', address: '10 Downing Street, London' },
                'South Africa': { province: 'Western Cape', postcode: '8001', address: 'Parliament of South Africa, Cape Town' },
                'Japan': { province: 'Tokyo', postcode: '100-0001', address: '1 Chiyoda, Chiyoda City, Tokyo' },
                'South Korea': { province: 'Seoul', postcode: '03051', address: '1 Sejong-daero, Jongno-gu, Seoul' },
                'Malaysia': { province: 'Federal Territory', postcode: '50050', address: 'Dataran Merdeka, Kuala Lumpur' },
                'Thailand': { province: 'Bangkok', postcode: '10200', address: 'Grand Palace, Bangkok' },
                'Philippines': { province: 'Metro Manila', postcode: '1000', address: 'Rizal Park, Manila' },
                'Singapore': { province: 'Singapore', postcode: '018956', address: '1 Parliament Place, Singapore' },
                'Turkey': { province: 'Ankara', postcode: '06030', address: 'Ataturk Boulevard, Ankara' },
                'Ireland': { province: 'Dublin', postcode: 'D02 AF30', address: 'O\'Connell Street, Dublin' },
                'Mexico': { province: 'CDMX', postcode: '06000', address: 'Zocalo Square, Mexico City' }
            };
            return capitalAddresses[country] || { province: '', postcode: '', address: '' };
        }

        // Address Management Functions
        function addAddressRow(addressId = null, country = '', province = '', postcode = '', address = '') {
            const container = document.getElementById('addressesContainer');
            const id = addressId || `addr_${addressCounter++}`;
            
            const row = document.createElement('div');
            row.className = 'address-row';
            row.id = id;
            row.innerHTML = `
                <select class="addr-country" style="width: 150px;" onchange="updateAddressFromCountry('${id}'); saveAddresses();">
                    <option value="">-- Select Country --</option>
                    <option value="Australia" ${country === 'Australia' ? 'selected' : ''}>Australia</option>
                    <option value="United States" ${country === 'United States' ? 'selected' : ''}>United States</option>
                    <option value="Canada" ${country === 'Canada' ? 'selected' : ''}>Canada</option>
                    <option value="New Zealand" ${country === 'New Zealand' ? 'selected' : ''}>New Zealand</option>
                    <option value="Indonesia" ${country === 'Indonesia' ? 'selected' : ''}>Indonesia</option>
                    <option value="India" ${country === 'India' ? 'selected' : ''}>India</option>
                    <option value="United Kingdom" ${country === 'United Kingdom' ? 'selected' : ''}>United Kingdom</option>
                    <option value="South Africa" ${country === 'South Africa' ? 'selected' : ''}>South Africa</option>
                    <option value="Japan" ${country === 'Japan' ? 'selected' : ''}>Japan</option>
                    <option value="South Korea" ${country === 'South Korea' ? 'selected' : ''}>South Korea</option>
                    <option value="Malaysia" ${country === 'Malaysia' ? 'selected' : ''}>Malaysia</option>
                    <option value="Thailand" ${country === 'Thailand' ? 'selected' : ''}>Thailand</option>
                    <option value="Philippines" ${country === 'Philippines' ? 'selected' : ''}>Philippines</option>
                    <option value="Singapore" ${country === 'Singapore' ? 'selected' : ''}>Singapore</option>
                    <option value="Turkey" ${country === 'Turkey' ? 'selected' : ''}>Turkey</option>
                    <option value="Ireland" ${country === 'Ireland' ? 'selected' : ''}>Ireland</option>
                    <option value="Mexico" ${country === 'Mexico' ? 'selected' : ''}>Mexico</option>
                </select>
                <input type="text" class="addr-province" placeholder="Province/State" value="${province}" style="width: 120px;" onchange="saveAddresses()" onblur="saveAddresses()">
                <input type="text" class="addr-postcode" placeholder="Postcode" value="${postcode}" style="width: 100px;" onchange="saveAddresses()" onblur="saveAddresses()">
                <input type="text" class="addr-address" placeholder="Street Address" value="${address}" style="width: 250px;" onchange="saveAddresses()" onblur="saveAddresses()">
                <button class="remove-btn" onclick="removeAddressRow('${id}')">Remove</button>
            `;
            container.appendChild(row);
            saveAddresses(); // Save after adding
        }

        function updateAddressFromCountry(rowId) {
            const row = document.getElementById(rowId);
            if (!row) return;
            
            const countrySelect = row.querySelector('.addr-country');
            const provinceInput = row.querySelector('.addr-province');
            const postcodeInput = row.querySelector('.addr-postcode');
            const addressInput = row.querySelector('.addr-address');
            
            if (countrySelect && provinceInput && postcodeInput && addressInput) {
                const country = countrySelect.value;
                
                if (country && country !== '') {
                    const capitalAddr = getCapitalCityAddress(country);
                    
                    // Auto-populate with capital city address when country is selected
                    provinceInput.value = capitalAddr.province;
                    postcodeInput.value = capitalAddr.postcode;
                    addressInput.value = capitalAddr.address;
                } else {
                    // Clear fields if no country selected
                    provinceInput.value = '';
                    postcodeInput.value = '';
                    addressInput.value = '';
                }
            }
        }

        function removeAddressRow(id) {
            const row = document.getElementById(id);
            if (row) {
                row.remove();
                saveAddresses(); // Save after removing
            }
        }

        function getAllAddresses() {
            const addresses = [];
            const rows = document.querySelectorAll('.address-row');
            
            const usedIds = new Set(); // Track used IDs to prevent duplicates
            
            rows.forEach((row, idx) => {
                const country = row.querySelector('.addr-country')?.value || '';
                const province = row.querySelector('.addr-province')?.value || '';
                const postcode = row.querySelector('.addr-postcode')?.value || '';
                const address = row.querySelector('.addr-address')?.value || '';
                
                // Ensure unique ID - if missing or duplicate, generate new one
                let rowId = row.id;
                if (!rowId || usedIds.has(rowId) || (rowId === 'addr_0' && idx > 0)) {
                    // Generate a new unique ID
                    do {
                        rowId = `addr_${addressCounter++}`;
                    } while (usedIds.has(rowId));
                    
                    row.id = rowId;
                    // Update the remove button onclick to use the new ID
                    const removeBtn = row.querySelector('.remove-btn');
                    if (removeBtn) {
                        removeBtn.setAttribute('onclick', `removeAddressRow('${rowId}')`);
                    }
                }
                usedIds.add(rowId);
                
                if (country) { // Only add if country is selected
                    addresses.push({
                        id: rowId, // Use the actual row ID
                        country: country,
                        province: province,
                        postcode: postcode,
                        address: address
                    });
                }
            });
            
            return addresses;
        }

        // Load saved addresses from localStorage
        function loadSavedAddresses() {
            try {
                const saved = localStorage.getItem('shippingAddresses');
                if (saved) {
                    const addresses = JSON.parse(saved);
                    if (Array.isArray(addresses) && addresses.length > 0) {
                        // Find the highest address counter to avoid ID conflicts
                        const usedIds = new Set();
                        addresses.forEach(addr => {
                            if (addr.id && addr.id.startsWith('addr_')) {
                                const num = parseInt(addr.id.replace('addr_', '')) || 0;
                                if (num >= addressCounter) {
                                    addressCounter = num + 1;
                                }
                                usedIds.add(addr.id);
                            }
                        });
                        
                        // Now add all addresses with their saved IDs (or generate new ones if missing/duplicate)
                        addresses.forEach((addr, idx) => {
                            // If ID is missing or duplicate, generate a new one
                            let addrId = addr.id;
                            if (!addrId || usedIds.has(addrId) || (addrId === 'addr_0' && idx > 0)) {
                                do {
                                    addrId = `addr_${addressCounter++}`;
                                } while (usedIds.has(addrId));
                            }
                            usedIds.add(addrId);
                            addAddressRow(addrId, addr.country, addr.province, addr.postcode, addr.address);
                        });
                        return;
                    }
                }
            } catch (e) {
                console.warn('Failed to load saved addresses:', e);
            }
            // If no saved addresses, add empty address row (user selects country first)
            // Check if container is empty (no addresses were loaded)
            const container = document.getElementById('addressesContainer');
            if (container && container.children.length === 0) {
                // Add one empty address row - user will select country first
                addAddressRow();
            }
        }
        
        // Save addresses to localStorage
        function saveAddresses() {
            try {
                const addresses = getAllAddresses();
                localStorage.setItem('shippingAddresses', JSON.stringify(addresses));
                console.log(`üíæ Saved ${addresses.length} addresses to localStorage`);
            } catch (e) {
                console.error('Failed to save addresses:', e);
            }
        }
        
        // Initialize with saved addresses or default on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Check carrier service status on page load
            if (SHOP_DOMAIN) {
                checkCarrierServiceStatus();
            }
            loadSavedAddresses();
        });
        
        // Release wake lock when page is unloaded
        window.addEventListener('beforeunload', () => {
            releaseWakeLock();
        });
        
        // Also release wake lock when page becomes hidden (user switches tabs)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Don't release immediately - calculations might still be running
                // But log a warning
                if (wakeLock || noSleepVideo) {
                    log('‚ö†Ô∏è Page hidden - wake lock may be released by browser');
                }
            }
        });

        // Modal Functions
        function showConfigModal() {
            console.log('Opening config modal');
            document.getElementById('configModal').style.display = 'block';
            document.getElementById('configShop').value = SHOP_DOMAIN;
        }

        function closeConfigModal() {
            document.getElementById('configModal').style.display = 'none';
        }

        async function saveConfig() {
            const shop = document.getElementById('configShop').value.trim();
            const token = document.getElementById('configToken').value.trim();
            
            if (!shop || !token) {
                document.getElementById('configMsg').innerText = "Please fill all fields";
                document.getElementById('configMsg').style.color = "red";
                return;
            }

            document.getElementById('configMsg').innerText = "Connecting...";
            document.getElementById('configMsg').style.color = "blue";

            try {
                const response = await fetch('/api/auth/manual', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ shop, accessToken: token })
                });
                
                const result = await response.json();
                if (result.success) {
                    SHOP_DOMAIN = shop;
                    localStorage.setItem('shopDomain', shop); // Save to localStorage
                    document.getElementById('shopName').innerText = SHOP_DOMAIN;
                    document.getElementById('configMsg').innerText = "Connected! You can now import products.";
                    document.getElementById('configMsg').style.color = "green";
                    setTimeout(closeConfigModal, 1500);
                    loadProducts(); // Try loading again
                } else {
                    document.getElementById('configMsg').innerText = "Error: " + result.error;
                    document.getElementById('configMsg').style.color = "red";
                }
            } catch (e) {
                document.getElementById('configMsg').innerText = "Network Error: " + e.message;
                document.getElementById('configMsg').style.color = "red";
            }
        }

        async function loadProducts(page = 1, status = 'all', processed = 'all', search = '') {
            const processedFilter = document.getElementById('processedFilter')?.value || processed;
            const searchTerm = document.getElementById('searchInput')?.value?.trim() || search;
            log(`Fetching products from local DB (page ${page}, status: ${status}, processed: ${processedFilter}${searchTerm ? ', search: ' + searchTerm : ''})...`);
            const tbody = document.getElementById('tableBody');
            
            // CRITICAL: Clear table and products array IMMEDIATELY to prevent showing stale data
            tbody.innerHTML = '<tr><td colspan="12" style="text-align:center; padding: 20px;">Loading...</td></tr>';
            allProducts = []; // Clear the array to prevent renderTable from using old data
            
            try {
                let url = `/api/products?shop=${SHOP_DOMAIN}&limit=250&page=${page}`;
                if (status && status !== 'all') {
                    url += `&status=${status}`;
                }
                if (processedFilter && processedFilter !== 'all') {
                    url += `&processed=${processedFilter}`;
                }
                if (searchTerm) {
                    url += `&search=${encodeURIComponent(searchTerm)}`;
                }
                // Add cache busting to ensure fresh data
                url += `&_t=${Date.now()}`;
                
                console.log('API URL:', url);
                log(`API URL: ${url}`);
                const response = await fetch(url, {
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!data) {
                    throw new Error('Empty response from server');
                }
                
                if (data.products) {
                    currentPage = data.pagination.page;
                    totalProducts = data.pagination.total;
                    totalPages = data.pagination.pages;
                    
                    log(`Loaded ${data.products.length} products (page ${currentPage} of ${totalPages}, total: ${totalProducts}).`);
                    
                    // Always clear the table first - CRITICAL to prevent showing old data
                    tbody.innerHTML = '';
                    
                    // Update the displayed products array with ONLY the filtered results
                    allProducts = data.products;
                    
                    // Apply current sort if one is active
                    if (currentSortColumn) {
                        allProducts = applySort(allProducts, currentSortColumn, currentSortDirection);
                        // Update sort indicator
                        document.querySelectorAll('.sort-indicator').forEach(ind => {
                            ind.className = 'sort-indicator';
                        });
                        const indicator = document.getElementById(`sort-${currentSortColumn}`);
                        if (indicator) {
                            indicator.className = `sort-indicator ${currentSortDirection}`;
                        }
                    }
                    
                    if (allProducts.length === 0) {
                        let message = '';
                        if (searchTerm) {
                            message = `No products found matching "${searchTerm}". Try a different search term or clear the search.`;
                        } else if (status === 'active') {
                            message = `No active products found. ${totalProducts > 0 ? `All ${totalProducts} products are draft or archived.` : 'No products in database.'}`;
                        } else {
                            message = `No products found matching the "${status}" filter.`;
                        }
                        tbody.innerHTML = `<tr><td colspan="12" style="text-align:center; padding: 20px;">
                            ${message}<br><br>
                            ${searchTerm ? 'Try clearing the search or using different keywords.' : (status === 'active' ? 'To see active products, make sure products are published in Shopify.' : 'Try selecting a different status filter.')}
                        </td></tr>`;
                    } else {
                        // Render ONLY the products we just fetched (may be sorted)
                        renderTable(allProducts);
                        updatePaginationControls();
                    }
                    document.getElementById('stats').innerText = `Showing ${allProducts.length} of ${totalProducts} products (page ${currentPage}/${totalPages})`;
                    
                    // Update metafield statistics (don't block if it fails)
                    try {
                        updateMetafieldStats().catch(err => {
                            console.warn('Failed to update metafield stats:', err);
                            // Don't block rendering if this fails
                        });
                    } catch (err) {
                        console.warn('Error calling updateMetafieldStats:', err);
                        // Don't block rendering if this fails
                    }
                } else if (data.error) {
                    log("Error: " + data.error);
                    tbody.innerHTML = `<tr><td colspan="12" style="text-align:center; color: red;">Error: ${data.error}</td></tr>`;
                    if (data.error.includes('required') || data.error.includes('found')) {
                         showConfigModal(); // Auto-show config if shop missing
                    }
                }
            } catch (e) {
                log("Error loading products: " + e.message);
                tbody.innerHTML = `<tr><td colspan="12" style="text-align:center; color: red;">Connection Error</td></tr>`;
            }
        }

        async function importFromShopify() {
            log("Starting import from Shopify...");
            // Visual feedback
            const btn = document.getElementById('importBtn');
            const progressDiv = document.getElementById('importProgress');
            const statusDiv = document.getElementById('importStatus');
            const originalText = btn.innerText;
            
            btn.innerText = "‚è≥ Importing...";
            btn.disabled = true;
            progressDiv.style.display = 'block';
            statusDiv.textContent = 'Connecting to Shopify...';

            try {
                statusDiv.textContent = 'Fetching products and metafields via GraphQL...';
                // Add timestamp to force fresh import (bypass cache)
                const timestamp = Date.now();
                const response = await fetch(`/api/products/import?shop=${SHOP_DOMAIN}&_t=${timestamp}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ force: true }) // Force update all products
                });
                const result = await response.json();
                if (result.success) {
                    const total = result.imported + result.updated;
                    const timeInfo = result.timeString ? ` (took ${result.timeString})` : '';
                    log(`‚úÖ Imported ${result.imported} new, updated ${result.updated} products. (Total: ${total})${timeInfo}`);
                    statusDiv.innerHTML = `‚úÖ <strong>Import Complete!</strong><br>Imported: ${result.imported} new, ${result.updated} updated (Total: ${total})${timeInfo ? `<br>‚è±Ô∏è Time: ${result.timeString}` : ''}`;
                    statusDiv.style.color = '#28a745';
                    
                    // Preserve current filters instead of resetting
                    const currentStatus = document.getElementById('statusFilter').value;
                    const currentProcessed = document.getElementById('processedFilter').value;
                    const currentSearch = document.getElementById('searchInput')?.value?.trim() || '';
                    
                    // Reload products with current filters after a short delay
                    setTimeout(() => {
                        loadProducts(currentPage, currentStatus, currentProcessed, currentSearch);
                        updateMetafieldStats();
                        // Hide progress after 3 seconds
                        setTimeout(() => {
                            progressDiv.style.display = 'none';
                        }, 3000);
                    }, 1000);
                } else {
                    log("‚ùå Import failed: " + (result.error || 'Unknown error'));
                    statusDiv.innerHTML = `‚ùå <strong>Import Failed:</strong> ${result.error || 'Unknown error'}`;
                    statusDiv.style.color = '#dc3545';
                    alert("Import Failed: " + (result.error || 'Unknown error'));
                    if (result.error === 'Shop not found or not authenticated') {
                        showConfigModal();
                    }
                    progressDiv.style.display = 'none';
                }
            } catch (e) {
                log("‚ùå Import error: " + e.message);
                statusDiv.innerHTML = `‚ùå <strong>Network Error:</strong> ${e.message}`;
                statusDiv.style.color = '#dc3545';
                alert("Network Error: " + e.message);
                progressDiv.style.display = 'none';
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }
        
        async function updateMetafieldStats() {
            try {
                const response = await fetch(`/api/products?shop=${SHOP_DOMAIN}&limit=250&page=1`);
                const data = await response.json();
                if (data.products && data.products.length > 0) {
                    let withMetafields = 0;
                    let withDimensions = 0;
                    const sampleSize = Math.min(data.products.length, 100);
                    
                    for (let i = 0; i < sampleSize; i++) {
                        const p = data.products[i];
                        if (p.metafields && p.metafields.length > 0) {
                            withMetafields++;
                            const hasDiameter = p.metafields.some(m => 
                                m.key === 'largest_diameter_raw' || 
                                m.key === 'largest_diameter_raw_mm_' ||
                                m.key === 'largest_diameter_raw_mm'
                            );
                            const hasHeight = p.metafields.some(m => 
                                m.key === 'height_raw' || 
                                m.key === 'height_raw_mm_' ||
                                m.key === 'height_raw_mm'
                            );
                            if (hasDiameter && hasHeight) {
                                withDimensions++;
                            }
                        }
                    }
                    
                    const statsDiv = document.getElementById('metafieldStats');
                    const percentage = sampleSize > 0 ? Math.round((withMetafields / sampleSize) * 100) : 0;
                    const dimPercentage = withMetafields > 0 ? Math.round((withDimensions / withMetafields) * 100) : 0;
                    
                    if (withMetafields === 0) {
                        statsDiv.innerHTML = '<span style="color: #dc3545;">‚ö†Ô∏è No metafields found - Import needed</span>';
                    } else {
                        statsDiv.innerHTML = `üìä Sample: ${withMetafields}/${sampleSize} have metafields (${percentage}%) | ${withDimensions} have dimensions (${dimPercentage}%)`;
                    }
                }
            } catch (e) {
                console.error('Error updating metafield stats:', e);
            }
        }

        function handleSearchInput(event) {
            // Search on Enter key or after 500ms of no typing
            if (event.key === 'Enter') {
                filterProducts();
            } else {
                // Debounce search - wait 500ms after user stops typing
                clearTimeout(window.searchTimeout);
                window.searchTimeout = setTimeout(() => {
                    filterProducts();
                }, 500);
            }
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            filterProducts();
        }

        function filterProducts() {
            const status = document.getElementById('statusFilter').value;
            const processed = document.getElementById('processedFilter').value;
            const search = document.getElementById('searchInput')?.value?.trim() || '';
            console.log('Filter changed to:', status, processed, search ? `search: ${search}` : '');
            currentStatus = status;
            currentPage = 1; // Reset to first page when filtering
            
            // CRITICAL: Clear everything immediately and synchronously
            allProducts = [];
            calculatedData = {}; // Also clear calculated data
            allFilteredProductIds = []; // Clear "Select All" state when filters change
            
            // Force clear the table immediately with a clear message
            const tbody = document.getElementById('tableBody');
            // Remove all child nodes to ensure complete clearing
            while (tbody.firstChild) {
                tbody.removeChild(tbody.firstChild);
            }
            // Then set innerHTML
            tbody.innerHTML = `<tr><td colspan="12" style="text-align:center; padding: 20px; background: #f0f0f0;">
                <strong>Filtering...</strong>
            </td></tr>`;
            
            // Force a reflow to ensure the DOM update is visible
            tbody.offsetHeight;
            
            // Update stats immediately
            const statsEl = document.getElementById('stats');
            if (statsEl) statsEl.innerText = 'Filtering...';
            
            log(`Filtering by status: ${status}, processed: ${processed}${search ? ', search: ' + search : ''}`);
            // Use setTimeout(0) to ensure the DOM update happens before async load
            setTimeout(() => {
                loadProducts(currentPage, status, processed, search);
            }, 0);
        }
        
        function updatePaginationControls() {
            // Remove existing pagination if any
            const existingPagination = document.getElementById('paginationControls');
            if (existingPagination) {
                existingPagination.remove();
            }
            
            if (totalPages <= 1) return; // No pagination needed
            
            // Create pagination controls
            const pagination = document.createElement('div');
            pagination.id = 'paginationControls';
            pagination.style.cssText = 'margin: 20px 0; text-align: center;';
            
            let html = '<div style="display: inline-flex; gap: 10px; align-items: center;">';
            
            const processedFilter = document.getElementById('processedFilter')?.value || 'all';
            const currentSearch = document.getElementById('searchInput')?.value?.trim() || '';
            const searchParam = currentSearch ? `, '${currentSearch.replace(/'/g, "\\'")}'` : '';
            
            // Previous button
            if (currentPage > 1) {
                html += `<button onclick="loadProducts(${currentPage - 1}, '${currentStatus}', '${processedFilter}'${searchParam})" class="secondary">‚Üê Previous</button>`;
            }
            
            // Page numbers
            html += `<span>Page ${currentPage} of ${totalPages}</span>`;
            
            // Next button
            if (currentPage < totalPages) {
                html += `<button onclick="loadProducts(${currentPage + 1}, '${currentStatus}', '${processedFilter}'${searchParam})" class="secondary">Next ‚Üí</button>`;
            }
            
            html += '</div>';
            pagination.innerHTML = html;
            
            // Insert after the table
            const table = document.getElementById('productsTable');
            table.parentNode.insertBefore(pagination, table.nextSibling);
        }

        // Sorting state
        let currentSortColumn = null;
        let currentSortDirection = 'asc'; // 'asc' or 'desc'

        function applySort(products, column, direction) {
            if (!column || !products || products.length === 0) return products;
            
            return [...products].sort((a, b) => {
                let aVal, bVal;

                switch (column) {
                    case 'title':
                        aVal = (a.title || '').toLowerCase();
                        bVal = (b.title || '').toLowerCase();
                        break;
                    case 'status':
                        aVal = (a.status || '').toLowerCase();
                        bVal = (b.status || '').toLowerCase();
                        break;
                    case 'weight':
                        aVal = parseFloat(a.variants?.[0]?.weight || 0) || 0;
                        bVal = parseFloat(b.variants?.[0]?.weight || 0) || 0;
                        break;
                    case 'length':
                        aVal = parseFloat(a.imageEnrichment?.dimensions?.largest_diameter_raw || 0) || 0;
                        bVal = parseFloat(b.imageEnrichment?.dimensions?.largest_diameter_raw || 0) || 0;
                        break;
                    case 'height':
                        aVal = parseFloat(a.imageEnrichment?.dimensions?.height_raw || 0) || 0;
                        bVal = parseFloat(b.imageEnrichment?.dimensions?.height_raw || 0) || 0;
                        break;
                    case 'width':
                        aVal = parseFloat(a.imageEnrichment?.dimensions?.width_raw || 0) || 0;
                        bVal = parseFloat(b.imageEnrichment?.dimensions?.width_raw || 0) || 0;
                        break;
                    case 'code':
                        // Get code from shipping rates or calculated data (one code per product)
                        let aCode = null;
                        let bCode = null;
                        
                        // Get code from first shipping rate (all rates should have the same code)
                        if (a.shippingRates && a.shippingRates.length > 0) {
                            const firstRate = a.shippingRates.find(r => r.assignedCode !== undefined && r.assignedCode !== null && r.assignedCode !== '');
                            if (firstRate) {
                                aCode = firstRate.assignedCode;
                            }
                        }
                        if (!aCode && calculatedData[a._id]?.suggestedCode !== undefined) {
                            aCode = calculatedData[a._id].suggestedCode;
                        }
                        
                        if (b.shippingRates && b.shippingRates.length > 0) {
                            const firstRate = b.shippingRates.find(r => r.assignedCode !== undefined && r.assignedCode !== null && r.assignedCode !== '');
                            if (firstRate) {
                                bCode = firstRate.assignedCode;
                            }
                        }
                        if (!bCode && calculatedData[b._id]?.suggestedCode !== undefined) {
                            bCode = calculatedData[b._id].suggestedCode;
                        }
                        
                        aVal = aCode !== null ? Number(aCode) : -1;
                        bVal = bCode !== null ? Number(bCode) : -1;
                        break;
                    case 'cost':
                        // Get max shipping cost (cheapest or express, whichever is higher)
                        const aRates = a.shippingRates || [];
                        const bRates = b.shippingRates || [];
                        let aMaxCost = 0;
                        let bMaxCost = 0;
                        
                        aRates.forEach(rate => {
                            const max = Math.max(rate.cheapPriceUSD || 0, rate.expressPriceUSD || 0);
                            if (max > aMaxCost) aMaxCost = max;
                        });
                        if (!aMaxCost && calculatedData[a._id]) {
                            aMaxCost = Math.max(
                                calculatedData[a._id].maxCheapPriceUSD || 0,
                                calculatedData[a._id].maxExpressPriceUSD || 0
                            );
                        }
                        
                        bRates.forEach(rate => {
                            const max = Math.max(rate.cheapPriceUSD || 0, rate.expressPriceUSD || 0);
                            if (max > bMaxCost) bMaxCost = max;
                        });
                        if (!bMaxCost && calculatedData[b._id]) {
                            bMaxCost = Math.max(
                                calculatedData[b._id].maxCheapPriceUSD || 0,
                                calculatedData[b._id].maxExpressPriceUSD || 0
                            );
                        }
                        
                        aVal = aMaxCost;
                        bVal = bMaxCost;
                        break;
                    default:
                        return 0;
                }

                // Compare values
                if (typeof aVal === 'string') {
                    return direction === 'asc' 
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                } else {
                    return direction === 'asc' 
                        ? aVal - bVal
                        : bVal - aVal;
                }
            });
        }

        function sortTable(column) {
            // Toggle sort direction if clicking the same column
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortDirection = 'asc';
            }

            // Update sort indicators
            document.querySelectorAll('.sort-indicator').forEach(ind => {
                ind.className = 'sort-indicator';
            });
            const indicator = document.getElementById(`sort-${column}`);
            if (indicator) {
                indicator.className = `sort-indicator ${currentSortDirection}`;
            }

            // Apply sort and update
            const sortedProducts = applySort(allProducts, column, currentSortDirection);
            allProducts = sortedProducts;
            renderTable(sortedProducts);
        }

        function renderTable(products) {
            const tbody = document.getElementById('tableBody');
            // CRITICAL: Always clear first, no matter what
            tbody.innerHTML = '';
            
            if (!products || products.length === 0) {
                return; // Don't render anything if no products
            }

            products.forEach((p, index) => {
                // Get shipping rates from product.shippingRates (from DB) or calculatedData (from frontend calc)
                let calc = calculatedData[p._id] || {};
                
                // If product has shippingRates from DB, use those instead
                if (p.shippingRates && p.shippingRates.length > 0) {
                    // Calculate max prices from shipping rates
                    let maxCheapPrice = 0;
                    let maxExpressPrice = 0;
                    let cheapService = '';
                    let expressService = '';
                    let suggestedCode = null;
                    
                    p.shippingRates.forEach(rate => {
                        if (rate.cheapPriceUSD > maxCheapPrice) {
                            maxCheapPrice = rate.cheapPriceUSD;
                            cheapService = rate.cheapService || '';
                        }
                        if (rate.expressPriceUSD > maxExpressPrice) {
                            maxExpressPrice = rate.expressPriceUSD;
                            expressService = rate.expressService || '';
                        }
                        // Get code from first rate (all rates for a product should have the same code)
                        if (suggestedCode === null && rate.assignedCode !== undefined && rate.assignedCode !== null && rate.assignedCode !== '') {
                            suggestedCode = rate.assignedCode;
                        }
                    });
                    
                    calc = {
                        ...calc,
                        maxCheapPriceUSD: maxCheapPrice,
                        maxExpressPriceUSD: maxExpressPrice,
                        cheapService: cheapService,
                        expressService: expressService,
                        suggestedCode: suggestedCode !== null ? suggestedCode : calc.suggestedCode
                    };
                }
                
                const variant = p.variants && p.variants[0] ? p.variants[0] : {};
                
                // Show weight from variant (which should be updated from metafield during import)
                // If variant weight exists and is > 0, use it (it was updated from metafield)
                // Otherwise fall back to metafield directly
                let currentWeight = 'N/A';
                if (variant.weight && variant.weight > 0) {
                    // Variant weight was updated from metafield during import
                    currentWeight = `${variant.weight} ${variant.weight_unit || 'kg'}`;
                    // Check if it came from metafield (indicate this)
                    if (p.metafields && p.metafields.length > 0) {
                        const weightMeta = p.metafields.find(m => 
                            (m.namespace === 'custom' && m.key === 'weight_raw_kg_') ||
                            m.key === 'weight_raw_kg_' ||
                            m.key === 'weight_raw_kg'
                        );
                        if (weightMeta && parseFloat(weightMeta.value) === variant.weight) {
                            currentWeight = `${variant.weight} kg (from metafield)`;
                        }
                    }
                } else if (p.metafields && p.metafields.length > 0) {
                    // Fallback to metafield if variant weight not set
                    const weightMeta = p.metafields.find(m => 
                        (m.namespace === 'custom' && m.key === 'weight_raw_kg_') ||
                        m.key === 'weight_raw_kg_' ||
                        m.key === 'weight_raw_kg'
                    );
                    if (weightMeta) {
                        currentWeight = `${weightMeta.value} kg (from metafield)`;
                    }
                }
                const imgSrc = p.originalImages && p.originalImages[0] ? p.originalImages[0].url : '';
                
                // Get dimensions from calculated data or metafields
                // Look for largest_diameter_raw and height_raw metafields
                // Debug: Log metafields for first product
                if (index === 0 && p.metafields) {
                    console.log(`[DEBUG] First product "${p.title}" metafields:`, {
                        count: p.metafields.length,
                        keys: p.metafields.map(m => `${m.namespace}.${m.key}`),
                        sample: p.metafields.slice(0, 3)
                    });
                }
                // Look for metafields with various key formats
                const diameterMeta = p.metafields?.find(m => 
                    m.key === 'largest_diameter_raw' || 
                    m.key === 'largest_diameter_raw_mm_' ||
                    m.key === 'largest_diameter_raw_mm'
                );
                const heightMeta = p.metafields?.find(m => 
                    m.key === 'height_raw' || 
                    m.key === 'height_raw_mm_' ||
                    m.key === 'height_raw_mm'
                );
                
                // Show raw metafield values (in mm) or calculated adjusted values (in cm)
                const length = calc.adjDimensions?.length 
                    ? calc.adjDimensions.length + ' cm' 
                    : (diameterMeta ? diameterMeta.value + ' mm' : '-');
                const height = calc.adjDimensions?.height 
                    ? calc.adjDimensions.height + ' cm' 
                    : (heightMeta ? heightMeta.value + ' mm' : '-');
                const width = calc.adjDimensions?.width 
                    ? calc.adjDimensions.width + ' cm' 
                    : (diameterMeta ? diameterMeta.value + ' mm' : '-'); // Use diameter for width too
                
                const status = p.status || 'active';
                const statusClass = status === 'active' ? 'badge-success' : status === 'draft' ? 'badge-pending' : 'badge-error';
                const isProcessed = p.shippingProcessed || false;
                const processedBadge = isProcessed ? '<span class="status-badge badge-success" style="margin-left: 5px; font-size: 10px;">‚úì Processed</span>' : '';
                // Create Shopify product link
                const shopifyProductUrl = p.shopifyId 
                    ? `https://${SHOP_DOMAIN}/admin/products/${p.shopifyId}`
                    : null;
                const productTitleLink = shopifyProductUrl 
                    ? `<a href="${shopifyProductUrl}" target="_blank" rel="noopener noreferrer" style="color: #007cba; text-decoration: none; font-weight: 500;" title="Open in Shopify Admin">${p.title} üîó</a>`
                    : p.title;
                
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><input type="checkbox" class="p-select" value="${p._id}"></td>
                    <td>${imgSrc ? `<img src="${imgSrc}" class="product-thumb">` : 'No Image'}</td>
                    <td>${productTitleLink}</td>
                    <td><span class="status-badge ${statusClass}">${status.charAt(0).toUpperCase() + status.slice(1)}</span>${processedBadge}</td>
                    <td>${currentWeight}</td>
                    <td id="length-${p._id}">${length}</td>
                    <td id="height-${p._id}">${height}</td>
                    <td id="width-${p._id}">${width}</td>
                    <td id="code-${p._id}">${calc.suggestedCode !== undefined && calc.suggestedCode !== null && calc.suggestedCode !== '' ? String(calc.suggestedCode) : '-'}</td>
                    <td id="cost-${p._id}">${calc.maxCheapPriceUSD ? '$' + calc.maxCheapPriceUSD.toFixed(2) : '-'}${calc.maxExpressPriceUSD ? ' / $' + calc.maxExpressPriceUSD.toFixed(2) : ''}</td>
                    <td id="carrier-${p._id}">${calc.cheapService || '-'}${calc.expressService ? ' / ' + calc.expressService : ''}</td>
                    <td>
                        <button class="secondary" style="padding: 5px 10px; font-size: 12px;" onclick="calculateSingle('${p._id}')">Calc</button>
                        ${(addressResults[p._id] && Object.keys(addressResults[p._id]).length > 0) || (p.shippingRates && p.shippingRates.length > 0) ? `<button class="toggle-details-btn" onclick="toggleShippingDetails('${p._id}')" id="toggle-${p._id}">Show Rates</button>` : ''}
                    </td>
                `;
                tbody.appendChild(tr);
                
                // Add expandable details row if there are address results OR shipping rates from DB
                if ((addressResults[p._id] && Object.keys(addressResults[p._id]).length > 0) || (p.shippingRates && p.shippingRates.length > 0)) {
                    const detailsRow = document.createElement('tr');
                    detailsRow.className = 'shipping-details-row';
                    detailsRow.id = `details-${p._id}`;
                    detailsRow.innerHTML = `
                        <td colspan="12" class="shipping-details-cell">
                            <div style="margin-bottom: 10px; font-weight: bold; color: #007cba;">üìä Shipping Rates by Location:</div>
                            <div id="shipping-details-content-${p._id}"></div>
                        </td>
                    `;
                    tbody.appendChild(detailsRow);
                    // Store product data for updateShippingDetails to access
                    if (!window.productDataForDetails) window.productDataForDetails = {};
                    window.productDataForDetails[p._id] = p;
                    updateShippingDetails(p._id);
                }
            });
        }
        
        function toggleShippingDetails(productId) {
            let detailsRow = document.getElementById(`details-${productId}`);
            const toggleBtn = document.getElementById(`toggle-${productId}`);
            
            // If details row doesn't exist, create it
            if (!detailsRow && toggleBtn) {
                const calcButton = document.querySelector(`button[onclick="calculateSingle('${productId}')"]`);
                if (calcButton) {
                    const tr = calcButton.closest('tr');
                    if (tr) {
                        detailsRow = document.createElement('tr');
                        detailsRow.className = 'shipping-details-row';
                        detailsRow.id = `details-${productId}`;
                        detailsRow.innerHTML = `
                            <td colspan="12" class="shipping-details-cell">
                                <div style="margin-bottom: 10px; font-weight: bold; color: #007cba;">üìä Shipping Rates by Location:</div>
                                <div id="shipping-details-content-${productId}"></div>
                            </td>
                        `;
                        tr.parentNode.insertBefore(detailsRow, tr.nextSibling);
                        
                        // Store product data if available
                        const product = allProducts.find(p => p._id === productId);
                        if (product) {
                            if (!window.productDataForDetails) window.productDataForDetails = {};
                            window.productDataForDetails[productId] = product;
                        }
                    }
                }
            }
            
            if (detailsRow && toggleBtn) {
                if (detailsRow.classList.contains('expanded')) {
                    detailsRow.classList.remove('expanded');
                    toggleBtn.innerText = 'Show Rates';
                } else {
                    detailsRow.classList.add('expanded');
                    toggleBtn.innerText = 'Hide Rates';
                    updateShippingDetails(productId);
                }
            }
        }
        
        function updateProductRowInTable(product) {
            // Update the product row with new shipping data
            const row = document.querySelector(`tr:has(button[onclick="calculateSingle('${product._id}')"])`);
            if (!row) return;
            
            // Get max prices from shipping rates
            const rates = product.shippingRates || [];
            let maxCheapPrice = 0;
            let maxExpressPrice = 0;
            let cheapService = '';
            let expressService = '';
            
            rates.forEach(rate => {
                if (rate.cheapPriceUSD > maxCheapPrice) {
                    maxCheapPrice = rate.cheapPriceUSD;
                    cheapService = rate.cheapService || '';
                }
                if (rate.expressPriceUSD > maxExpressPrice) {
                    maxExpressPrice = rate.expressPriceUSD;
                    expressService = rate.expressService || '';
                }
            });
            
            // Update cost cell
            const costCell = document.getElementById(`cost-${product._id}`);
            if (costCell) {
                costCell.innerHTML = `${maxCheapPrice ? '$' + maxCheapPrice.toFixed(2) : '-'}${maxExpressPrice ? ' / $' + maxExpressPrice.toFixed(2) : ''}`;
            }
            
            // Update carrier cell
            const carrierCell = document.getElementById(`carrier-${product._id}`);
            if (carrierCell) {
                carrierCell.innerHTML = `${cheapService || '-'}${expressService ? ' / ' + expressService : ''}`;
            }
            
            // Update processed badge in status cell
            const statusCell = row.querySelector('td:nth-child(4)');
            if (statusCell && product.shippingProcessed) {
                if (!statusCell.innerHTML.includes('‚úì Processed')) {
                    statusCell.innerHTML += '<span class="status-badge badge-success" style="margin-left: 5px; font-size: 10px;">‚úì Processed</span>';
                }
            }
        }
        
        function updateProductRowWithRates(productId) {
            if (!addressResults[productId] || Object.keys(addressResults[productId]).length === 0) return;
            
            // Find the row by finding the button with the productId
            const calcButton = document.querySelector(`button[onclick="calculateSingle('${productId}')"]`);
            if (!calcButton) return;
            
            const tr = calcButton.closest('tr');
            if (!tr) return;
            
            // Find the action cell (last td)
            const actionCell = tr.querySelector('td:last-child');
            if (!actionCell) return;
            
            // Add or update the "Show Rates" button
            let toggleBtn = document.getElementById(`toggle-${productId}`);
            if (!toggleBtn) {
                toggleBtn = document.createElement('button');
                toggleBtn.className = 'toggle-details-btn';
                toggleBtn.id = `toggle-${productId}`;
                toggleBtn.innerText = 'Show Rates';
                toggleBtn.onclick = () => toggleShippingDetails(productId);
                actionCell.appendChild(toggleBtn);
            }
            
            // Add details row if it doesn't exist
            let detailsRow = document.getElementById(`details-${productId}`);
            if (!detailsRow) {
                detailsRow = document.createElement('tr');
                detailsRow.className = 'shipping-details-row';
                detailsRow.id = `details-${productId}`;
                detailsRow.innerHTML = `
                    <td colspan="12" class="shipping-details-cell">
                        <div style="margin-bottom: 10px; font-weight: bold; color: #007cba;">üìä Shipping Rates by Location:</div>
                        <div id="shipping-details-content-${productId}"></div>
                    </td>
                `;
                tr.parentNode.insertBefore(detailsRow, tr.nextSibling);
            }
            
            updateShippingDetails(productId);
        }
        
        // Track which products are showing all options
        const showAllOptions = {};
        
        function toggleAllOptions(productId, addressId) {
            const key = `${productId}_${addressId}`;
            showAllOptions[key] = !showAllOptions[key];
            updateShippingDetails(productId);
        }
        
        async function updateShippingDetails(productId) {
            const contentDiv = document.getElementById(`shipping-details-content-${productId}`);
            if (!contentDiv) return;
            
            // Check if we have shipping rates from DB
            const productData = window.productDataForDetails?.[productId];
            let dbShippingRates = productData?.shippingRates || [];
            
            // If rates exist but don't have allRoutes, fetch full rates from API
            const needsFullRates = dbShippingRates.length > 0 && dbShippingRates.some(rate => !rate.allRoutes && rate.hasAllRoutes);
            if (needsFullRates) {
                try {
                    const response = await fetch(`/api/products/${productId}/shipping-rates?shop=${SHOP_DOMAIN}`);
                    if (response.ok) {
                        const data = await response.json();
                        dbShippingRates = data.shippingRates || [];
                        // Update cached product data
                        if (window.productDataForDetails) {
                            window.productDataForDetails[productId] = {
                                ...window.productDataForDetails[productId],
                                shippingRates: dbShippingRates
                            };
                        }
                    }
                } catch (err) {
                    console.warn('Failed to fetch full shipping rates:', err);
                }
            }
            
            // If we have DB shipping rates, use those instead of addressResults
            if (dbShippingRates.length > 0) {
                let html = '';
                const addresses = getAllAddresses();
                
                // Group rates by address
                const ratesByAddress = {};
                dbShippingRates.forEach(rate => {
                    const addrId = rate.addressId || '';
                    if (!ratesByAddress[addrId]) {
                        ratesByAddress[addrId] = [];
                    }
                    ratesByAddress[addrId].push(rate);
                });
                
                // Sort addresses by most expensive rate (cheapest + express combined)
                const sortedAddressIds = Object.keys(ratesByAddress).sort((addrIdA, addrIdB) => {
                    const ratesA = ratesByAddress[addrIdA];
                    const ratesB = ratesByAddress[addrIdB];
                    
                    // Get max price for each address (cheapest + express)
                    const maxPriceA = Math.max(
                        ...ratesA.map(r => Math.max(r.cheapPriceUSD || 0, r.expressPriceUSD || 0))
                    );
                    const maxPriceB = Math.max(
                        ...ratesB.map(r => Math.max(r.cheapPriceUSD || 0, r.expressPriceUSD || 0))
                    );
                    
                    return maxPriceB - maxPriceA; // Descending order (most expensive first)
                });
                
                sortedAddressIds.forEach(addressId => {
                    const rates = ratesByAddress[addressId];
                    const firstRate = rates[0];
                    const addr = addresses.find(a => a.id === addressId);
                    
                    let addrLabel = addressId;
                    // Check for countryName first (from DB), then country, then address lookup
                    if (firstRate.countryName) {
                        addrLabel = firstRate.countryName;
                        if (firstRate.province) addrLabel += `, ${firstRate.province}`;
                        if (firstRate.postcode) addrLabel += ` ${firstRate.postcode}`;
                    } else if (firstRate.country) {
                        addrLabel = firstRate.country;
                        if (firstRate.province) addrLabel += `, ${firstRate.province}`;
                        if (firstRate.postcode) addrLabel += ` ${firstRate.postcode}`;
                    } else if (addr) {
                        addrLabel = `${addr.country}${addr.province ? `, ${addr.province}` : ''}${addr.postcode ? ` ${addr.postcode}` : ''}`;
                    }
                    
                    html += `<div class="shipping-location">`;
                    html += `<div class="shipping-location-header">üìç ${addrLabel}</div>`;
                    
                    // Show assigned code if available
                    if (firstRate.assignedCode !== undefined && firstRate.assignedCode !== null && firstRate.assignedCode !== '') {
                        html += `<div class="shipping-rate-item" style="margin-bottom: 8px;">`;
                        html += `<span class="rate-label">üî¢ Code:</span>`;
                        html += `<span class="rate-value" style="font-weight: bold; color: #007cba;">${firstRate.assignedCode}</span>`;
                        html += `</div>`;
                    }
                    
                    // Show cheap and express rates
                    if (firstRate.cheapService) {
                        const days = firstRate.cheapDays ? ` (${firstRate.cheapDays} days)` : '';
                        html += `<div class="shipping-rate-item">`;
                        html += `<span class="rate-label">üí∞ Cheap:</span>`;
                        html += `<span class="rate-value">$${firstRate.cheapPriceUSD?.toFixed(2) || '0.00'} - ${firstRate.cheapService || 'N/A'}${days}</span>`;
                        html += `</div>`;
                    }
                    
                    if (firstRate.expressService) {
                        const days = firstRate.expressDays ? ` (${firstRate.expressDays} days)` : '';
                        html += `<div class="shipping-rate-item">`;
                        html += `<span class="rate-label">üöÄ Express:</span>`;
                        html += `<span class="rate-value">$${firstRate.expressPriceUSD?.toFixed(2) || '0.00'} - ${firstRate.expressService || 'N/A'}${days}</span>`;
                        html += `</div>`;
                    }
                    
                    if (!firstRate.cheapService && !firstRate.expressService) {
                        html += `<div style="color: #856404;">‚ö†Ô∏è No shipping options available</div>`;
                    }
                    
                    html += `</div>`;
                });
                
                contentDiv.innerHTML = html;
                return;
            }
            
            // Fall back to addressResults (from frontend calculation)
            if (!addressResults[productId]) return;
            
            const addresses = getAllAddresses();
            const productAddressResults = addressResults[productId];
            let html = '';
            
            // Sort addresses by most expensive rate (cheapest + express combined)
            const sortedAddressIds = Object.keys(productAddressResults).sort((addrIdA, addrIdB) => {
                const resultA = productAddressResults[addrIdA];
                const resultB = productAddressResults[addrIdB];
                
                // Get max price for each address
                const maxPriceA = Math.max(
                    resultA.maxCheapPriceUSD || 0,
                    resultA.maxExpressPriceUSD || 0
                );
                const maxPriceB = Math.max(
                    resultB.maxCheapPriceUSD || 0,
                    resultB.maxExpressPriceUSD || 0
                );
                
                return maxPriceB - maxPriceA; // Descending order (most expensive first)
            });
            
            sortedAddressIds.forEach(addressId => {
                const addrResult = productAddressResults[addressId];
                const addr = addresses.find(a => a.id === addressId);
                
                // Build address label - prefer stored country name, then DOM address, then extract from logs, finally use ID
                let addrLabel = addressId;
                if (addrResult.countryName) {
                    // Use country name from backend result
                    addrLabel = addrResult.countryName;
                    if (addrResult.province) addrLabel += `, ${addrResult.province}`;
                    if (addrResult.postcode) addrLabel += ` ${addrResult.postcode}`;
                } else if (addr) {
                    // Use address from DOM
                    addrLabel = `${addr.country}${addr.province ? `, ${addr.province}` : ''}${addr.postcode ? ` ${addr.postcode}` : ''}`;
                } else if (addrResult.debugLogs && Array.isArray(addrResult.debugLogs)) {
                    // Try to extract country name from debug logs
                    const targetLog = addrResult.debugLogs.find(log => log.includes('üåç Target:'));
                    if (targetLog) {
                        // Extract country name from log like "üåç Target: Singapore (SG), Singapore 018956, 1 Parliament Place, Singapore"
                        const match = targetLog.match(/üåç Target:\s*([^(]+)/);
                        if (match) {
                            addrLabel = match[1].trim();
                        }
                    }
                }
                
                const showAllKey = `${productId}_${addressId}`;
                const showAll = showAllOptions[showAllKey] || false;
                
                html += `<div class="shipping-location">`;
                html += `<div class="shipping-location-header">üìç ${addrLabel}</div>`;
                
                // Try to get code from product's shipping rates for this address
                let locationCode = null;
                if (productData?.shippingRates) {
                    const rateForAddress = productData.shippingRates.find(r => r.addressId === addressId);
                    if (rateForAddress && rateForAddress.assignedCode !== undefined && rateForAddress.assignedCode !== null && rateForAddress.assignedCode !== '') {
                        locationCode = rateForAddress.assignedCode;
                    }
                }
                
                // Show assigned code if available
                if (locationCode !== null) {
                    html += `<div class="shipping-rate-item" style="margin-bottom: 8px;">`;
                    html += `<span class="rate-label">üî¢ Code:</span>`;
                    html += `<span class="rate-value" style="font-weight: bold; color: #007cba;">${locationCode}</span>`;
                    html += `</div>`;
                }
                
                if (addrResult.error) {
                    html += `<div style="color: #dc3545;">‚ùå Error: ${addrResult.error}</div>`;
                } else {
                    // Helper function to format transit days
                    const formatDays = (minDays, maxDays) => {
                        if (!minDays && !maxDays) return '';
                        if (minDays === maxDays) return ` (${minDays} days)`;
                        return ` (${minDays}-${maxDays} days)`;
                    };
                    
                    // Show selected options (cheap/express)
                    if (addrResult.cheapService) {
                        const cheapOption = addrResult.cheapOption || {};
                        const days = formatDays(cheapOption.minTimeInTransit, cheapOption.maxTimeInTransit);
                        html += `<div class="shipping-rate-item">`;
                        html += `<span class="rate-label">üí∞ Cheap:</span>`;
                        html += `<span class="rate-value">$${addrResult.maxCheapPriceUSD?.toFixed(2) || '0.00'} - ${addrResult.cheapService || 'N/A'}${days}</span>`;
                        html += `</div>`;
                    }
                    
                    if (addrResult.expressService) {
                        const expressOption = addrResult.expressOption || {};
                        const days = formatDays(expressOption.minTimeInTransit, expressOption.maxTimeInTransit);
                        html += `<div class="shipping-rate-item">`;
                        html += `<span class="rate-label">üöÄ Express:</span>`;
                        html += `<span class="rate-value">$${addrResult.maxExpressPriceUSD?.toFixed(2) || '0.00'} - ${addrResult.expressService || 'N/A'}${days}</span>`;
                        html += `</div>`;
                    }
                    
                    if (!addrResult.cheapService && !addrResult.expressService) {
                        html += `<div style="color: #856404;">‚ö†Ô∏è No shipping options available</div>`;
                    }
                    
                    // Show "View All Rates" button if we have all routes data
                    if (addrResult.allRoutes && Array.isArray(addrResult.allRoutes) && addrResult.allRoutes.length > 0) {
                        html += `<div style="margin-top: 10px;">`;
                        html += `<button onclick="toggleAllOptions('${productId}', '${addressId}')" style="padding: 8px 15px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">`;
                        html += showAll ? 'üîΩ Hide All Rates' : 'üìä View All Rates';
                        html += ` <span style="font-size: 11px; opacity: 0.9;">(${addrResult.allRoutes.length} routes)</span>`;
                        html += `</button>`;
                        html += `</div>`;
                        
                        // Show all options if toggled
                        if (showAll) {
                            // Sort routes by price (most expensive to cheapest)
                            const sortedRoutes = [...addrResult.allRoutes].sort((a, b) => {
                                const priceA = a.totalPrice || 0;
                                const priceB = b.totalPrice || 0;
                                return priceB - priceA; // Descending order (most expensive first)
                            });
                            
                            html += `<div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; max-height: 500px; overflow-y: auto;">`;
                            html += `<div style="font-weight: bold; margin-bottom: 12px; color: #333; font-size: 14px;">üìã All Available Routes (${sortedRoutes.length} total, sorted by price: most expensive first):</div>`;
                            
                            // Add table header
                            html += `<div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 1fr; gap: 8px; padding: 8px; background: #e9ecef; border-radius: 4px; margin-bottom: 8px; font-weight: bold; font-size: 12px;">`;
                            html += `<div>Service Name</div>`;
                            html += `<div style="text-align: right;">Price (USD)</div>`;
                            html += `<div style="text-align: center;">Days</div>`;
                            html += `<div>Provider</div>`;
                            html += `<div style="text-align: center;">Status</div>`;
                            html += `</div>`;
                            
                            sortedRoutes.forEach((route, idx) => {
                                const routeDays = formatDays(route.minTimeInTransit, route.maxTimeInTransit);
                                // Use same conversion rate as backend (1/7.20 = 0.1389 RMB to USD)
                                const RMB_TO_USD = 1 / 7.20;
                                const priceUSD = route.totalPrice ? parseFloat((route.totalPrice * RMB_TO_USD).toFixed(2)) : 0;
                                const priceDisplay = priceUSD > 0 ? `$${priceUSD.toFixed(2)}` : 'N/A';
                                const isSelected = (route.serviceCode === addrResult.cheapOption?.serviceCode) || 
                                                  (route.serviceCode === addrResult.expressOption?.serviceCode);
                                const rowBg = isSelected ? '#d4edda' : (idx % 2 === 0 ? 'white' : '#f8f9fa');
                                const borderColor = isSelected ? '#28a745' : '#dee2e6';
                                
                                html += `<div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 1fr; gap: 8px; padding: 10px; margin-bottom: 4px; border-left: 4px solid ${borderColor}; background: ${rowBg}; border-radius: 4px; font-size: 12px;">`;
                                
                                // Service Name
                                html += `<div>`;
                                html += `<strong>${route.serviceName || 'N/A'}</strong>`;
                                if (isSelected) {
                                    html += ` <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">SELECTED</span>`;
                                }
                                html += `</div>`;
                                
                                // Price
                                html += `<div style="text-align: right; font-weight: bold; color: #007cba;">${priceDisplay}</div>`;
                                
                                // Days
                                html += `<div style="text-align: center; color: #666;">${routeDays || 'N/A'}</div>`;
                                
                                // Provider
                                html += `<div style="color: #666; font-size: 11px;">${route.providerName || 'N/A'}</div>`;
                                
                                // Status
                                html += `<div style="text-align: center;">`;
                                if (route.available === false) {
                                    html += `<span style="color: #dc3545; font-size: 10px;">‚ö†Ô∏è Unavailable</span>`;
                                } else {
                                    html += `<span style="color: #28a745; font-size: 10px;">‚úì Available</span>`;
                                }
                                html += `</div>`;
                                
                                html += `</div>`;
                                
                                // Show unavailable reason if present
                                if (route.available === false && route.unavailableReason) {
                                    html += `<div style="padding: 4px 10px; margin-bottom: 8px; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 3px; font-size: 11px; color: #856404;">`;
                                    html += `‚ö†Ô∏è ${route.unavailableReason}`;
                                    html += `</div>`;
                                }
                            });
                            
                            html += `</div>`;
                        }
                    } else {
                        // Debug: Show if allRoutes is missing and provide way to inspect
                        html += `<div style="margin-top: 10px; padding: 8px; background: #fff3cd; border-radius: 4px; font-size: 11px; color: #856404;">`;
                        html += `‚ö†Ô∏è All routes data not available (for debugging: allRoutes=${addrResult.allRoutes ? 'exists' : 'missing'})`;
                        html += `<br><button onclick="inspectRawData('${productId}', '${addressId}')" style="margin-top: 5px; padding: 5px 10px; background: #856404; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">üîç Inspect Raw Data in Console</button>`;
                        html += `</div>`;
                    }
                    
                    // Always show "View All Rates" button
                    html += `<div style="margin-top: 10px;">`;
                    html += `<button onclick="viewAllRatesPlainText('${productId}', '${addressId}', '${addrLabel.replace(/'/g, "\\'")}')" style="padding: 8px 15px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">üìã View All Rates (Plain Text)</button>`;
                    html += `</div>`;
                }
                
                html += `</div>`;
            });
            
            contentDiv.innerHTML = html || '<div style="color: #666;">No shipping rates calculated yet.</div>';
        }
        
        // Debug function to inspect raw data in console
        function inspectRawData(productId, addressId) {
            if (!addressResults[productId] || !addressResults[productId][addressId]) {
                console.error('No data found for product:', productId, 'address:', addressId);
                console.log('Available addressResults:', addressResults);
                return;
            }
            
            const data = addressResults[productId][addressId];
            console.group(`üîç Raw Shipping Data: Product ${productId}, Address ${addressId}`);
            console.log('Full address result:', data);
            console.log('All routes:', data.allRoutes);
            console.log('All routes count:', data.allRoutes ? data.allRoutes.length : 0);
            console.log('Cheap option:', data.cheapOption);
            console.log('Express option:', data.expressOption);
            console.log('Prices:', {
                cheap: data.maxCheapPriceUSD,
                express: data.maxExpressPriceUSD
            });
            console.groupEnd();
            
            // Also show in alert for quick view
            alert(`Raw Data Summary:\n\nAll Routes: ${data.allRoutes ? data.allRoutes.length : 0}\nCheap: $${data.maxCheapPriceUSD}\nExpress: $${data.maxExpressPriceUSD}\n\nCheck console for full details.`);
        }
        
        // View all rates in plain text popup
        function viewAllRatesPlainText(productId, addressId, locationLabel) {
            if (!addressResults[productId] || !addressResults[productId][addressId]) {
                alert('No data found for this product/address combination.');
                return;
            }
            
            const data = addressResults[productId][addressId];
            const routes = data.allRoutes || [];
            const RMB_TO_USD = 1 / 7.20;
            
            // Build plain text output
            let text = `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
            text += `ALL SHIPPING RATES - ${locationLabel}\n`;
            text += `Product: ${data.title || 'N/A'}\n`;
            text += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
            
            if (routes.length === 0) {
                text += `‚ö†Ô∏è No routes available\n`;
                text += `\nDebug Info:\n`;
                text += `- allRoutes exists: ${data.allRoutes ? 'YES' : 'NO'}\n`;
                text += `- allRoutes type: ${typeof data.allRoutes}\n`;
                text += `- allRoutes length: ${data.allRoutes ? data.allRoutes.length : 'N/A'}\n`;
                text += `- Available keys: ${Object.keys(data).join(', ')}\n`;
            } else {
                // Sort by price
                const sortedRoutes = [...routes].sort((a, b) => {
                    const priceA = a.totalPrice || 0;
                    const priceB = b.totalPrice || 0;
                    return priceA - priceB;
                });
                
                text += `Total Routes: ${sortedRoutes.length}\n`;
                text += `Sorted by: Price (Lowest to Highest)\n\n`;
                
                // Selected options
                if (data.cheapService || data.expressService) {
                    text += `SELECTED OPTIONS:\n`;
                    text += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
                    if (data.cheapService) {
                        const cheapPrice = data.maxCheapPriceUSD ? `$${data.maxCheapPriceUSD.toFixed(2)}` : 'N/A';
                        const cheapDays = data.cheapOption ? `${data.cheapOption.minTimeInTransit || '?'}-${data.cheapOption.maxTimeInTransit || '?'} days` : '';
                        text += `üí∞ CHEAP: ${data.cheapService} - ${cheapPrice} ${cheapDays}\n`;
                    }
                    if (data.expressService) {
                        const expressPrice = data.maxExpressPriceUSD ? `$${data.maxExpressPriceUSD.toFixed(2)}` : 'N/A';
                        const expressDays = data.expressOption ? `${data.expressOption.minTimeInTransit || '?'}-${data.expressOption.maxTimeInTransit || '?'} days` : '';
                        text += `üöÄ EXPRESS: ${data.expressService} - ${expressPrice} ${expressDays}\n`;
                    }
                    text += `\n`;
                }
                
                text += `ALL AVAILABLE ROUTES:\n`;
                text += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
                
                sortedRoutes.forEach((route, idx) => {
                    const priceUSD = route.totalPrice ? (route.totalPrice * RMB_TO_USD).toFixed(2) : 'N/A';
                    const days = route.minTimeInTransit && route.maxTimeInTransit 
                        ? (route.minTimeInTransit === route.maxTimeInTransit 
                            ? `${route.minTimeInTransit} days` 
                            : `${route.minTimeInTransit}-${route.maxTimeInTransit} days`)
                        : 'N/A';
                    
                    const isSelected = (route.serviceCode === data.cheapOption?.serviceCode) || 
                                      (route.serviceCode === data.expressOption?.serviceCode);
                    const selectedMark = isSelected ? ' ‚≠ê SELECTED' : '';
                    
                    text += `${idx + 1}. ${route.serviceName || 'N/A'}${selectedMark}\n`;
                    text += `   Price: $${priceUSD} (¬•${route.totalPrice?.toFixed(2) || 'N/A'})\n`;
                    text += `   Transit: ${days}\n`;
                    if (route.providerName) {
                        text += `   Provider: ${route.providerName}\n`;
                    }
                    if (route.serviceCode) {
                        text += `   Service Code: ${route.serviceCode}\n`;
                    }
                    if (route.available === false) {
                        text += `   ‚ö†Ô∏è UNAVAILABLE: ${route.unavailableReason || 'Unknown reason'}\n`;
                    } else {
                        text += `   ‚úì Available\n`;
                    }
                    if (route.weightLowLimit || route.weightHighLimit) {
                        text += `   Weight Limits: ${route.weightLowLimit || 0}kg - ${route.weightHighLimit || 'unlimited'}kg\n`;
                    }
                    text += `\n`;
                });
            }
            
            text += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
            
            // Create modal with plain text
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center;';
            modal.innerHTML = `
                <div style="background: white; padding: 20px; border-radius: 4px; max-width: 90%; max-height: 90%; overflow: auto; position: relative; font-family: monospace;">
                    <button onclick="this.closest('div[style*=\"position: fixed\"]').remove()" style="position: absolute; top: 10px; right: 10px; background: #dc3545; color: white; border: none; border-radius: 4px; padding: 8px 15px; cursor: pointer; font-size: 14px; font-weight: bold;">‚úï Close</button>
                    <h3 style="margin-top: 0; margin-bottom: 15px; font-family: sans-serif;">All Shipping Rates - ${locationLabel}</h3>
                    <pre style="background: #f8f9fa; padding: 15px; border: 1px solid #ddd; border-radius: 4px; overflow-x: auto; font-size: 12px; line-height: 1.6; max-height: 75vh; white-space: pre-wrap; word-wrap: break-word;">${text}</pre>
                    <button onclick="navigator.clipboard.writeText(\`${text.replace(/`/g, '\\`')}\`); alert('Copied to clipboard!');" style="margin-top: 10px; padding: 8px 15px; background: #007cba; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">üìã Copy to Clipboard</button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // Export raw data to JSON file
        function exportRawData(productId, addressId, locationLabel) {
            if (!addressResults[productId] || !addressResults[productId][addressId]) {
                alert('No data found for this product/address combination.');
                return;
            }
            
            const data = addressResults[productId][addressId];
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `shipping-rates-${productId}-${addressId}-${locationLabel.replace(/[^a-z0-9]/gi, '_')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function toggleSelectAll() {
            const checked = document.getElementById('selectAll').checked;
            document.querySelectorAll('.p-select').forEach(cb => cb.checked = checked);
            // Clear allFilteredProductIds if unchecking (user wants manual selection)
            if (!checked) {
                allFilteredProductIds = [];
            }
        }

        function getSelectedIds() {
            return Array.from(document.querySelectorAll('.p-select:checked')).map(cb => cb.value);
        }

        // Store all product IDs matching current filter (for "Select All" functionality)
        let allFilteredProductIds = [];

        async function selectAllProducts() {
            const status = document.getElementById('statusFilter').value;
            const processed = document.getElementById('processedFilter').value;
            const search = document.getElementById('searchInput')?.value?.trim() || '';
            
            log(`üìã Fetching all product IDs matching current filter...`);
            
            try {
                // Fetch all product IDs matching the filter
                let url = `/api/products/ids?shop=${SHOP_DOMAIN}`;
                if (status && status !== 'all') {
                    url += `&status=${status}`;
                }
                if (processed && processed !== 'all') {
                    url += `&processed=${processed}`;
                }
                if (search) {
                    url += `&search=${encodeURIComponent(search)}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.productIds && data.productIds.length > 0) {
                    allFilteredProductIds = data.productIds;
                    log(`‚úÖ Found ${allFilteredProductIds.length} products matching current filter`);
                    
                    // Check all checkboxes on current page
                    document.querySelectorAll('.p-select').forEach(cb => {
                        if (allFilteredProductIds.includes(cb.value)) {
                            cb.checked = true;
                        }
                    });
                    
                    document.getElementById('selectAll').checked = true;
                    alert(`‚úÖ Selected ${allFilteredProductIds.length} products matching current filter.\n\nYou can now click "Calculate Shipping (Selected)" to process all of them.`);
                } else {
                    log(`‚ö†Ô∏è No products found matching current filter`);
                    alert(`No products found matching current filter.`);
                }
            } catch (e) {
                log(`‚ùå Error fetching product IDs: ${e.message}`);
                alert(`Error: ${e.message}`);
            }
        }

        // Show dialog for selecting which already-processed products to recalculate
        function showProcessedProductsDialog(processedProducts, totalSelected) {
            return new Promise((resolve) => {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';
                
                // Create modal content
                const modal = document.createElement('div');
                modal.style.cssText = 'background: white; padding: 20px; border-radius: 8px; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
                
                modal.innerHTML = `
                    <h2 style="margin-top: 0;">‚ö†Ô∏è Already-Processed Products</h2>
                    <p>${processedProducts.length} of ${totalSelected} selected product(s) already have shipping rates calculated.</p>
                    <p><strong>Select which products to recalculate:</strong></p>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin: 10px 0;">
                        <label style="display: block; margin-bottom: 10px;">
                            <input type="checkbox" id="selectAllProcessed" checked style="margin-right: 8px;">
                            <strong>Select All (${processedProducts.length})</strong>
                        </label>
                        <hr style="margin: 10px 0;">
                        ${processedProducts.map((p, idx) => `
                            <label style="display: block; margin-bottom: 8px; padding: 5px;">
                                <input type="checkbox" class="processed-product-checkbox" value="${p.id}" checked style="margin-right: 8px;">
                                ${p.title} <span style="color: #666; font-size: 0.9em;">(${p.ratesCount} rates)</span>
                            </label>
                        `).join('')}
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
                        <button id="cancelProcessedDialog" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                        <button id="confirmProcessedDialog" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Continue</button>
                    </div>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                // Select all checkbox handler
                const selectAllCheckbox = modal.querySelector('#selectAllProcessed');
                const productCheckboxes = modal.querySelectorAll('.processed-product-checkbox');
                
                selectAllCheckbox.addEventListener('change', (e) => {
                    productCheckboxes.forEach(cb => {
                        cb.checked = e.target.checked;
                    });
                });
                
                // Individual checkbox handler
                productCheckboxes.forEach(cb => {
                    cb.addEventListener('change', () => {
                        const allChecked = Array.from(productCheckboxes).every(c => c.checked);
                        selectAllCheckbox.checked = allChecked;
                    });
                });
                
                // Cancel button
                modal.querySelector('#cancelProcessedDialog').addEventListener('click', () => {
                    document.body.removeChild(overlay);
                    resolve(null);
                });
                
                // Confirm button
                modal.querySelector('#confirmProcessedDialog').addEventListener('click', () => {
                    const selectedIds = Array.from(productCheckboxes)
                        .filter(cb => cb.checked)
                        .map(cb => cb.value);
                    
                    document.body.removeChild(overlay);
                    resolve({ selectedIds });
                });
            });
        }

        async function calculateAllProducts() {
            // Check if a calculation is already running
            if (window.shippingPollInterval) {
                return alert("‚ö†Ô∏è A calculation is already in progress. Please wait for it to complete before starting a new one.");
            }
            
            const status = document.getElementById('statusFilter').value;
            const processed = document.getElementById('processedFilter').value;
            const search = document.getElementById('searchInput')?.value?.trim() || '';
            
            const addresses = getAllAddresses();
            if (addresses.length === 0) return alert("Add at least one shipping address");
            
            if (!confirm(`üöÄ Calculate shipping for ALL products matching current filter?\n\nThis will process all products (not just the current page).\n\nCurrent filter: Status=${status}, Processed=${processed}${search ? `, Search="${search}"` : ''}\n\nThis may take a long time. Continue?`)) {
                return;
            }
            
            log(`üìã Fetching all product IDs matching current filter...`);
            
            try {
                // Fetch all product IDs matching the filter
                let url = `/api/products/ids?shop=${SHOP_DOMAIN}`;
                if (status && status !== 'all') {
                    url += `&status=${status}`;
                }
                if (processed && processed !== 'all') {
                    url += `&processed=${processed}`;
                }
                if (search) {
                    url += `&search=${encodeURIComponent(search)}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (!data.productIds || data.productIds.length === 0) {
                    alert(`No products found matching current filter.`);
                    return;
                }
                
                const allIds = data.productIds;
                log(`‚úÖ Found ${allIds.length} products matching filter. Starting calculation...`);
                
                // Acquire wake lock to prevent screen sleep
                await acquireWakeLock();
                
                // Disable button
                const calcBtn = event?.target || document.querySelector('button[onclick="calculateAllProducts()"]');
                if (calcBtn) {
                    calcBtn.disabled = true;
                    calcBtn.innerText = `‚è≥ Calculating ${allIds.length} products...`;
                }
                
                // Start calculation in background
                fetch('/api/shipping/calculate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        productIds: allIds, 
                        shop: SHOP_DOMAIN,
                        addresses: addresses
                    })
                }).catch(async (err) => {
                    log(`‚ùå Error starting calculation: ${err.message}`);
                    // Release wake lock on error
                    await releaseWakeLock();
                    if (calcBtn) {
                        calcBtn.disabled = false;
                        calcBtn.innerText = 'üöÄ Calculate All Products';
                    }
                });
                
                // Start polling for updates
                let processedCount = 0;
                let pollInterval = null;
                let isPolling = false; // Prevent concurrent polling
                const startTime = Date.now();
                
                // Clear any existing polling interval
                if (window.shippingPollInterval) {
                    clearInterval(window.shippingPollInterval);
                }
                
                const pollForUpdates = async () => {
                    // Prevent concurrent polling
                    if (isPolling) return;
                    
                    // Skip polling if tab is hidden (screen sleep/background tab)
                    if (document.hidden) {
                        return; // Will retry when tab becomes visible again
                    }
                    
                    try {
                        isPolling = true;
                        
                        // Count how many of our products are now processed (before reload)
                        const ourProcessedCountBefore = allProducts.filter(p => 
                            allIds.includes(p._id) && p.shippingProcessed
                        ).length;
                        
                        // Reload products to get latest shipping rates (every poll when progress changes, or every 5th poll otherwise)
                        const pollCount = Math.floor((Date.now() - startTime) / 10000);
                        const shouldReload = (ourProcessedCountBefore < allIds.length && pollCount % 5 === 0) || (ourProcessedCountBefore > processedCount);
                        
                        if (shouldReload) {
                            try {
                                await loadProducts(currentPage, status, processed, search);
                            } catch (loadErr) {
                                // Ignore network suspension errors - will retry next time
                                if (!loadErr.message.includes('ERR_NETWORK_IO_SUSPENDED') && 
                                    !loadErr.message.includes('Failed to fetch')) {
                                    log(`‚ö†Ô∏è Error loading products: ${loadErr.message}`);
                                }
                            }
                        }
                        
                        // Count how many of our products are now processed (after reload)
                        const ourProcessedCount = allProducts.filter(p => 
                            allIds.includes(p._id) && p.shippingProcessed
                        ).length;
                        
                        if (ourProcessedCount > processedCount) {
                            processedCount = ourProcessedCount;
                            const progress = Math.round((processedCount / allIds.length) * 100);
                            
                            if (calcBtn) {
                                calcBtn.innerText = `‚è≥ Calculating... ${processedCount}/${allIds.length} (${progress}%)`;
                            }
                            
                            log(`üìä Progress: ${processedCount}/${allIds.length} products completed (${progress}%)`);
                            
                            // If we didn't reload above but progress changed, reload now to show new shipping rates
                            if (!shouldReload) {
                                try {
                                    await loadProducts(currentPage, status, processed, search);
                                } catch (loadErr) {
                                    // Ignore network suspension errors
                                    if (!loadErr.message.includes('ERR_NETWORK_IO_SUSPENDED') && 
                                        !loadErr.message.includes('Failed to fetch')) {
                                        log(`‚ö†Ô∏è Error reloading products: ${loadErr.message}`);
                                    }
                                }
                            }
                        }
                        
                        // Stop polling if all products are processed or if we've been polling for more than 2 hours
                        if (processedCount >= allIds.length || (Date.now() - startTime) > 7200000) {
                            clearInterval(pollInterval);
                            if (window.shippingPollInterval) {
                                clearInterval(window.shippingPollInterval);
                                window.shippingPollInterval = null;
                            }
                            log(`‚úÖ Calculation complete! ${processedCount}/${allIds.length} products processed.`);
                            // Release wake lock
                            await releaseWakeLock();
                            if (calcBtn) {
                                calcBtn.disabled = false;
                                calcBtn.innerText = 'üöÄ Calculate All Products';
                            }
                        }
                    } catch (err) {
                        // Ignore network suspension errors - these are expected when screen sleeps
                        if (!err.message.includes('ERR_NETWORK_IO_SUSPENDED') && 
                            !err.message.includes('Failed to fetch')) {
                            log(`‚ö†Ô∏è Error checking progress: ${err.message}`);
                        }
                    } finally {
                        isPolling = false;
                    }
                };
                
                // Start polling every 10 seconds (reduced from 2 seconds)
                pollInterval = setInterval(pollForUpdates, 10000);
                window.shippingPollInterval = pollInterval; // Store globally to prevent duplicates
                pollForUpdates(); // Initial check after 2 seconds
                setTimeout(pollForUpdates, 2000);
                
                // Resume polling when tab becomes visible again (after screen sleep)
                const visibilityHandler = () => {
                    if (!document.hidden && pollInterval) {
                        // Tab is visible again - trigger immediate check
                        pollForUpdates();
                    }
                };
                document.addEventListener('visibilitychange', visibilityHandler);
                // Store handler so we can remove it later if needed
                window.shippingVisibilityHandler = visibilityHandler;
                
            } catch (e) {
                log(`‚ùå Error: ${e.message}`);
                alert(`Error: ${e.message}`);
                
                // Re-enable button
                const calcBtn = event?.target || document.querySelector('button[onclick="calculateAllProducts()"]');
                if (calcBtn) {
                    calcBtn.disabled = false;
                    calcBtn.innerText = 'üöÄ Calculate All Products';
                }
            }
        }

        async function calculateSelected() {
            // Check if a calculation is already running
            if (window.shippingPollInterval) {
                return alert("‚ö†Ô∏è A calculation is already in progress. Please wait for it to complete before starting a new one.");
            }
            
            // Prevent multiple simultaneous calls
            if (window.calculatingSelected) {
                return alert("‚ö†Ô∏è Please wait, a calculation is already starting...");
            }
            window.calculatingSelected = true;
            
            try {
                // Get checked products from current page
                let ids = getSelectedIds();
                const currentPageCheckboxes = document.querySelectorAll('.p-select');
                const checkedOnPageCount = ids.length;
                const totalOnPageCount = currentPageCheckboxes.length;
                const allCheckedOnPage = totalOnPageCount > 0 && checkedOnPageCount === totalOnPageCount;
                
                // Only use allFilteredProductIds if:
                // 1. It exists AND
                // 2. ALL checkboxes on current page are checked (user clicked "Select All" for this page) AND
                // 3. The "Select All" checkbox is also checked (indicates user wants all filtered products)
                const selectAllCheckbox = document.getElementById('selectAll');
                const selectAllChecked = selectAllCheckbox && selectAllCheckbox.checked;
                
                if (allFilteredProductIds && allFilteredProductIds.length > 0 && 
                    allCheckedOnPage && selectAllChecked && 
                    allFilteredProductIds.length > checkedOnPageCount) {
                    // User explicitly selected all products across all pages - use all filtered products
                    ids = allFilteredProductIds;
                    log(`üìã Using all ${ids.length} products from "Select All" (all ${checkedOnPageCount} on current page checked, Select All checkbox checked)`);
                } else {
                    // Use only the actually checked products (respects manual selection)
                    log(`üìã Using ${ids.length} checked product(s) from current selection`);
                }
                
                if (ids.length === 0) {
                    window.calculatingSelected = false;
                    return alert("Select products first");
                }
                
                const addresses = getAllAddresses();
                if (addresses.length === 0) {
                    window.calculatingSelected = false;
                    return alert("Add at least one shipping address");
                }
                
                // Check if any selected products are already processed
                // Fetch processed status from backend for all products (not just current page)
                const processedProductIds = [];
                const processedProductInfo = [];
                
                log(`üîç Checking which of ${ids.length} products are already processed...`);
                try {
                const checkResponse = await fetch('/api/products/check-processed', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        shop: SHOP_DOMAIN,
                        productIds: ids
                    })
                });
                
                if (checkResponse.ok) {
                    const checkData = await checkResponse.json();
                    if (checkData.processedProducts && checkData.processedProducts.length > 0) {
                        processedProductIds.push(...checkData.processedProducts.map(p => p.id));
                        processedProductInfo.push(...checkData.processedProducts);
                        log(`‚úÖ Found ${processedProductIds.length} already-processed products out of ${ids.length} total`);
                    } else {
                        log(`‚úÖ No already-processed products found`);
                    }
                } else {
                    log(`‚ö†Ô∏è Could not check processed status from backend, checking current page only...`);
                    // Fallback: check current page only
                    ids.forEach(id => {
                        const product = allProducts.find(p => p._id === id);
                        if (product && product.shippingProcessed) {
                            processedProductIds.push(id);
                            processedProductInfo.push({
                                id: id,
                                title: product.title || product._id,
                                ratesCount: product.shippingRates?.length || 0
                            });
                        }
                    });
                }
            } catch (checkErr) {
                log(`‚ö†Ô∏è Error checking processed status: ${checkErr.message}. Checking current page only...`);
                // Fallback: check current page only
                ids.forEach(id => {
                    const product = allProducts.find(p => p._id === id);
                    if (product && product.shippingProcessed) {
                        processedProductIds.push(id);
                        processedProductInfo.push({
                            id: id,
                            title: product.title || product._id,
                            ratesCount: product.shippingRates?.length || 0
                        });
                    }
                });
                }
                
                // If there are already-processed products, show selection dialog
                if (processedProductIds.length > 0) {
                    const result = await showProcessedProductsDialog(processedProductInfo, ids.length);
                    if (result === null) {
                        window.calculatingSelected = false;
                        return; // User cancelled
                    }
                    
                    // Filter out unselected processed products
                    if (result.selectedIds.length < processedProductIds.length) {
                        // Remove unselected processed products from ids
                        ids = ids.filter(id => {
                            if (processedProductIds.includes(id)) {
                                return result.selectedIds.includes(id);
                            }
                            return true; // Keep non-processed products (or products not on current page)
                        });
                        log(`üìã Selected ${result.selectedIds.length} of ${processedProductIds.length} already-processed products to recalculate`);
                    } else {
                        log(`‚ö†Ô∏è Recalculating shipping for ${processedProductIds.length} already-processed product(s)...`);
                    }
                }
                
                log(`üöÄ Starting calculation for ${ids.length} products to ${addresses.length} location(s)...`);
                addresses.forEach((addr, idx) => {
                    log(`  üìç Location ${idx + 1}: ${addr.country}${addr.province ? `, ${addr.province}` : ''}${addr.postcode ? ` ${addr.postcode}` : ''}`);
                });
                log(`‚è≥ This may take a few minutes. Processing products...`);
                
                // Disable calculate button during processing
                const calcBtn = event?.target || document.querySelector('button[onclick="calculateSelected()"]');
                if (calcBtn) {
                    calcBtn.disabled = true;
                    calcBtn.innerText = '‚è≥ Calculating...';
                }
                
                // For large batches (>500 products), use async processing with polling
                if (ids.length > 500) {
                log(`üìã Large batch detected (${ids.length} products). Using async processing...`);
                
                // Acquire wake lock to prevent screen sleep
                await acquireWakeLock();
                
                // Start calculation in background (fire and forget)
                fetch('/api/shipping/calculate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        productIds: ids, 
                        shop: SHOP_DOMAIN,
                        addresses: addresses
                    })
                }).catch(async (err) => {
                    log(`‚ùå Error starting calculation: ${err.message}`);
                    // Release wake lock on error
                    await releaseWakeLock();
                    if (calcBtn) {
                        calcBtn.disabled = false;
                        calcBtn.innerText = 'üßÆ Calculate Shipping (Selected)';
                    }
                });
                
                // Start polling for updates
                let processedCount = 0;
                let pollInterval = null;
                let isPolling = false; // Prevent concurrent polling
                const startTime = Date.now();
                const status = document.getElementById('statusFilter').value;
                const processed = document.getElementById('processedFilter').value;
                const search = document.getElementById('searchInput')?.value?.trim() || '';
                
                // Clear any existing polling interval
                if (window.shippingPollInterval) {
                    clearInterval(window.shippingPollInterval);
                }
                
                const pollForUpdates = async () => {
                    // Prevent concurrent polling
                    if (isPolling) return;
                    
                    // Skip polling if tab is hidden (screen sleep/background tab)
                    if (document.hidden) {
                        return; // Will retry when tab becomes visible again
                    }
                    
                    try {
                        isPolling = true;
                        
                        // Count how many of our products are now processed (before reload)
                        const ourProcessedCountBefore = allProducts.filter(p => 
                            ids.includes(p._id) && p.shippingProcessed
                        ).length;
                        
                        // Reload products to get latest shipping rates (every poll when progress changes, or every 5th poll otherwise)
                        const pollCount = Math.floor((Date.now() - startTime) / 10000);
                        const shouldReload = (ourProcessedCountBefore < ids.length && pollCount % 5 === 0) || (ourProcessedCountBefore > processedCount);
                        
                        if (shouldReload) {
                            try {
                                await loadProducts(currentPage, status, processed, search);
                            } catch (loadErr) {
                                // Ignore network suspension errors - will retry next time
                                if (!loadErr.message.includes('ERR_NETWORK_IO_SUSPENDED') && 
                                    !loadErr.message.includes('Failed to fetch')) {
                                    log(`‚ö†Ô∏è Error loading products: ${loadErr.message}`);
                                }
                            }
                        }
                        
                        // Count how many of our products are now processed (after reload)
                        const ourProcessedCount = allProducts.filter(p => 
                            ids.includes(p._id) && p.shippingProcessed
                        ).length;
                        
                        if (ourProcessedCount > processedCount) {
                            processedCount = ourProcessedCount;
                            const progress = Math.round((processedCount / ids.length) * 100);
                            
                            if (calcBtn) {
                                calcBtn.innerText = `‚è≥ Calculating... ${processedCount}/${ids.length} (${progress}%)`;
                            }
                            
                            log(`üìä Progress: ${processedCount}/${ids.length} products completed (${progress}%)`);
                            
                            // If we didn't reload above but progress changed, reload now to show new shipping rates
                            if (!shouldReload) {
                                try {
                                    await loadProducts(currentPage, status, processed, search);
                                } catch (loadErr) {
                                    // Ignore network suspension errors
                                    if (!loadErr.message.includes('ERR_NETWORK_IO_SUSPENDED') && 
                                        !loadErr.message.includes('Failed to fetch')) {
                                        log(`‚ö†Ô∏è Error reloading products: ${loadErr.message}`);
                                    }
                                }
                            }
                        }
                        
                        // Stop polling if all products are processed or if we've been polling for more than 2 hours
                        if (processedCount >= ids.length || (Date.now() - startTime) > 7200000) {
                            clearInterval(pollInterval);
                            if (window.shippingPollInterval) {
                                clearInterval(window.shippingPollInterval);
                                window.shippingPollInterval = null;
                            }
                            log(`‚úÖ Calculation complete! ${processedCount}/${ids.length} products processed.`);
                            // Release wake lock
                            await releaseWakeLock();
                            if (calcBtn) {
                                calcBtn.disabled = false;
                                calcBtn.innerText = 'üßÆ Calculate Shipping (Selected)';
                            }
                        }
                    } catch (err) {
                        // Ignore network suspension errors - these are expected when screen sleeps
                        if (!err.message.includes('ERR_NETWORK_IO_SUSPENDED') && 
                            !err.message.includes('Failed to fetch')) {
                            log(`‚ö†Ô∏è Error checking progress: ${err.message}`);
                        }
                    } finally {
                        isPolling = false;
                    }
                };
                
                // Start polling every 10 seconds (reduced from 2 seconds)
                pollInterval = setInterval(pollForUpdates, 10000);
                window.shippingPollInterval = pollInterval; // Store globally to prevent duplicates
                pollForUpdates(); // Initial check after 2 seconds
                setTimeout(pollForUpdates, 2000);
                
                // Resume polling when tab becomes visible again (after screen sleep)
                const visibilityHandler = () => {
                    if (!document.hidden && pollInterval) {
                        // Tab is visible again - trigger immediate check
                        pollForUpdates();
                    }
                };
                document.addEventListener('visibilitychange', visibilityHandler);
                // Store handler so we can remove it later if needed
                window.shippingVisibilityHandler = visibilityHandler;
                
                    return; // Exit early for large batches
                }
                
                // For smaller batches, use synchronous processing
                try {
                const response = await fetch('/api/shipping/calculate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        productIds: ids, 
                        shop: SHOP_DOMAIN,
                        addresses: addresses // Send array of addresses
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    log(`‚ùå HTTP Error ${response.status}: ${errorText}`);
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    let successCount = 0;
                    let errorCount = 0;
                    
                    // Initialize addressResults structure
                    if (!addressResults) addressResults = {};
                    
                    // Process results - they're grouped by product, with results per address
                    result.results.forEach(productResult => {
                        if (!productResult) {
                            errorCount++;
                            log(`‚ùå Invalid product result: result is null or undefined`);
                            return;
                        }
                        
                        const productId = productResult.productId;
                        
                        try {
                            if (productResult.error) {
                                errorCount++;
                                log(`‚ùå ${productResult.title || 'Unknown'}: ${productResult.error}`);
                            } else {
                                successCount++;
                            
                            // Store results per address
                            if (!addressResults[productId]) {
                                addressResults[productId] = {};
                            }
                            
                            // Process each address result
                            if (productResult.addressResults) {
                                Object.keys(productResult.addressResults).forEach(addressId => {
                                    const addrResult = productResult.addressResults[addressId];
                                    // Debug: Log what we're receiving from backend
                                    console.log(`[DEBUG] Received address result for ${addressId}:`, {
                                        hasAllRoutes: !!addrResult.allRoutes,
                                        allRoutesType: typeof addrResult.allRoutes,
                                        allRoutesLength: addrResult.allRoutes ? addrResult.allRoutes.length : 0,
                                        allKeys: Object.keys(addrResult)
                                    });
                                    // Ensure allRoutes is always an array (even if backend didn't send it)
                                    if (!addrResult.allRoutes || !Array.isArray(addrResult.allRoutes)) {
                                        console.warn(`[DEBUG] allRoutes is missing or not an array for ${addressId}, setting to empty array`);
                                        addrResult.allRoutes = [];
                                    }
                                    addressResults[productId][addressId] = addrResult;
                                    
                                    // Log per address
                                    const addr = addresses.find(a => a.id === addressId);
                                    const addrLabel = addr ? `${addr.country}${addr.province ? `, ${addr.province}` : ''}` : addressId;
                                    
                                    if (addrResult.cheapService) {
                                        log(`‚úÖ ${productResult.title} (${addrLabel}): Cheap: $${addrResult.maxCheapPriceUSD?.toFixed(2)} (${addrResult.cheapService}), Express: ${addrResult.expressService ? '$' + addrResult.maxExpressPriceUSD?.toFixed(2) + ' (' + addrResult.expressService + ')' : 'none'}`);
                                    } else {
                                        log(`‚ö†Ô∏è ${productResult.title} (${addrLabel}): Missing shipping options`);
                                    }
                                });
                            }
                            
                            // Store the final code (same for all addresses - based on max price)
                            // Use optional chaining and nullish coalescing for safety
                            const suggestedCode = productResult?.suggestedCode ?? -1;
                            const suggestedWeight = productResult?.suggestedWeight ?? 0;
                            const normCheapPrice = productResult?.normCheapPrice ?? 0;
                            const normExpressPrice = productResult?.normExpressPrice ?? 0;
                            
                            calculatedData[productId] = {
                                suggestedCode: suggestedCode,
                                suggestedWeight: suggestedWeight,
                                normCheapPrice: normCheapPrice,
                                normExpressPrice: normExpressPrice,
                                adjDimensions: productResult?.adjDimensions || productResult?.addressResults?.[Object.keys(productResult?.addressResults || {})[0]]?.adjDimensions
                            };
                            
                            // Update UI row with code (code is per product, not per address)
                            const codeCell = document.getElementById(`code-${productId}`);
                            if (codeCell) codeCell.innerText = suggestedCode >= 0 ? suggestedCode : '-';
                            
                            // Update dimensions
                            const lengthCell = document.getElementById(`length-${productId}`);
                            const heightCell = document.getElementById(`height-${productId}`);
                            const widthCell = document.getElementById(`width-${productId}`);
                            if (calculatedData[productId].adjDimensions) {
                                if (lengthCell) lengthCell.innerText = calculatedData[productId].adjDimensions.length + ' cm';
                                if (heightCell) heightCell.innerText = calculatedData[productId].adjDimensions.height + ' cm';
                                if (widthCell) widthCell.innerText = calculatedData[productId].adjDimensions.width + ' cm';
                            }
                            
                            // Update cost and carrier cells to show range or first address
                            const costCell = document.getElementById(`cost-${productId}`);
                            const carrierCell = document.getElementById(`carrier-${productId}`);
                            
                            // Update the row to show rates button
                            if (productResult.addressResults && Object.keys(productResult.addressResults).length > 0) {
                                updateProductRowWithRates(productId);
                            }
                            
                            if (productResult.addressResults && Object.keys(productResult.addressResults).length > 0) {
                                // Show range if multiple addresses, or first address if single
                                const addrResults = Object.values(productResult.addressResults);
                                if (addrResults.length === 1) {
                                    const r = addrResults[0];
                                    if (costCell) {
                                        const cheapPrice = r.maxCheapPriceUSD ? '$' + r.maxCheapPriceUSD.toFixed(2) : '-';
                                        const expressPrice = r.maxExpressPriceUSD ? ' / $' + r.maxExpressPriceUSD.toFixed(2) : '';
                                        costCell.innerText = cheapPrice + expressPrice;
                                    }
                                    if (carrierCell) {
                                        const cheapCarrier = r.cheapService || '-';
                                        const expressCarrier = r.expressService ? ' / ' + r.expressService : '';
                                        carrierCell.innerText = cheapCarrier + expressCarrier;
                                    }
                                } else {
                                    // Multiple addresses - show range
                                    const cheapPrices = addrResults.map(r => r.maxCheapPriceUSD || 0).filter(p => p > 0);
                                    const expressPrices = addrResults.map(r => r.maxExpressPriceUSD || 0).filter(p => p > 0);
                                    if (costCell) {
                                        const cheapRange = cheapPrices.length > 0 ? `$${Math.min(...cheapPrices).toFixed(2)}-$${Math.max(...cheapPrices).toFixed(2)}` : '-';
                                        const expressRange = expressPrices.length > 0 ? ` / $${Math.min(...expressPrices).toFixed(2)}-$${Math.max(...expressPrices).toFixed(2)}` : '';
                                        costCell.innerText = cheapRange + expressRange;
                                        costCell.title = `Rates vary by location (${addrResults.length} addresses)`;
                                    }
                                    if (carrierCell) {
                                        carrierCell.innerText = `${addrResults.length} locations`;
                                        carrierCell.title = 'Click to view details per location';
                                    }
                                }
                            }
                            } // Close else block
                        } catch (e) {
                            errorCount++;
                            const productTitle = productResult?.title || productResult?.productId || 'Unknown product';
                            const errorMsg = e?.message || e?.toString() || String(e);
                            log(`‚ùå ${productTitle}: ${errorMsg}`);
                            console.error('Error processing product result:', {
                                error: e,
                                errorName: e?.name,
                                errorMessage: e?.message,
                                errorStack: e?.stack,
                                productResult: productResult,
                                productResultKeys: productResult ? Object.keys(productResult) : 'N/A'
                            });
                        }
                    });
                    
                    log(`‚úÖ Calculation complete: ${successCount} successful, ${errorCount} errors`);
                    log(`üìä Note: Shipping codes are assigned per product (based on max price across all locations). Rates vary by country.`);
                } else {
                    log(`‚ùå Calculation failed: ${result.error || 'Unknown error'}`);
                    if (result.details) {
                        log(`Details: ${JSON.stringify(result.details)}`);
                    }
                }
                } catch (e) {
                    log(`‚ùå Calculation error: ${e.message}`);
                    log(`Stack: ${e.stack || 'No stack trace'}`);
                } finally {
                    // Clear the calculating flag
                    window.calculatingSelected = false;
                    
                    // Re-enable button
                    if (calcBtn) {
                        calcBtn.disabled = false;
                        calcBtn.innerText = 'üßÆ Calculate Shipping (Selected)';
                    }
                }
            } catch (outerErr) {
                // Outer try-catch for any errors in the function
                window.calculatingSelected = false;
                log(`‚ùå Unexpected error: ${outerErr.message}`);
            }
        }
        
        async function calculateSingle(id) {
            const addresses = getAllAddresses();
            if (addresses.length === 0) {
                // Fallback to single address if no addresses added yet
                addAddressRow();
                return calculateSingle(id); // Retry after adding default address
            }
            
            log(`üßÆ Calculating shipping for single product to ${addresses.length} location(s)...`);
            
            try {
                const requestBody = { 
                    productIds: [id], 
                    shop: SHOP_DOMAIN,
                    addresses: addresses
                };
                
                console.log('[DEBUG] Sending request with addresses:', JSON.stringify(requestBody, null, 2));
                
                const response = await fetch('/api/shipping/calculate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    log(`‚ùå HTTP Error ${response.status}: ${errorText}`);
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const result = await response.json();
                
                // Debug: Log the full response
                console.log('[DEBUG] Full API response:', result);
                
                if (result.success && result.results.length > 0) {
                    const productResult = result.results[0];
                    
                    // Debug: Log the product result structure
                    console.log('[DEBUG] Product result structure:', {
                        hasAddressResults: 'addressResults' in productResult,
                        addressResultsType: typeof productResult.addressResults,
                        addressResultsValue: productResult.addressResults,
                        addressResultsKeys: productResult.addressResults ? Object.keys(productResult.addressResults) : 'N/A',
                        allKeys: Object.keys(productResult)
                    });
                    
                    if (productResult.error) {
                        log(`‚ùå Error calculating ${productResult.title}: ${productResult.error}`);
                        return;
                    }
                    
                    // Store results per address
                    if (!addressResults[productResult.productId]) {
                        addressResults[productResult.productId] = {};
                    }
                    
                    if (productResult.addressResults && Object.keys(productResult.addressResults).length > 0) {
                        log(`üìä Shipping rates for ${productResult.title}:`);
                        Object.keys(productResult.addressResults).forEach(addressId => {
                            const addrResult = productResult.addressResults[addressId];
                            // Debug: Log what we're receiving
                            console.log(`[DEBUG] Storing address result for ${addressId}:`, {
                                hasAllRoutes: !!addrResult.allRoutes,
                                allRoutesType: typeof addrResult.allRoutes,
                                allRoutesLength: addrResult.allRoutes ? addrResult.allRoutes.length : 0,
                                allKeys: Object.keys(addrResult)
                            });
                            addressResults[productResult.productId][addressId] = addrResult;
                            
                            const addr = addresses.find(a => a.id === addressId);
                            const addrLabel = addr ? `${addr.country}${addr.province ? `, ${addr.province}` : ''}${addr.postcode ? ` ${addr.postcode}` : ''}` : addressId;
                            
                            if (addrResult.error) {
                                log(`  ‚ùå ${addrLabel}: ${addrResult.error}`);
                            } else if (addrResult.cheapService) {
                                const cheapPrice = addrResult.maxCheapPriceUSD ? '$' + addrResult.maxCheapPriceUSD.toFixed(2) : 'N/A';
                                const expressPrice = addrResult.maxExpressPriceUSD ? '$' + addrResult.maxExpressPriceUSD.toFixed(2) : 'none';
                                const expressService = addrResult.expressService || 'none';
                                log(`  ‚úÖ ${addrLabel}:`);
                                log(`     Cheap: ${cheapPrice} (${addrResult.cheapService})`);
                                log(`     Express: ${expressPrice} (${expressService})`);
                            } else {
                                log(`  ‚ö†Ô∏è ${addrLabel}: Missing shipping options`);
                            }
                            
                            // Show debug logs if available
                            if (addrResult.debugLogs && Array.isArray(addrResult.debugLogs) && addrResult.debugLogs.length > 0) {
                                log(`  üìã Detailed log for ${addrLabel}:`);
                                addrResult.debugLogs.forEach(debugMsg => {
                                    log(`     ${debugMsg}`);
                                });
                            }
                        });
                    } else {
                        log(`‚ö†Ô∏è No address results returned for ${productResult.title}`);
                    }
                    
                    // Store the final code (same for all addresses)
                    // Use optional chaining and nullish coalescing for safety
                    const suggestedCode = productResult?.suggestedCode ?? -1;
                    const suggestedWeight = productResult?.suggestedWeight ?? 0;
                    const normCheapPrice = productResult?.normCheapPrice ?? 0;
                    const normExpressPrice = productResult?.normExpressPrice ?? 0;
                    
                    calculatedData[productResult.productId] = {
                        suggestedCode: suggestedCode,
                        suggestedWeight: suggestedWeight,
                        normCheapPrice: normCheapPrice,
                        normExpressPrice: normExpressPrice,
                        adjDimensions: productResult?.adjDimensions || productResult?.addressResults?.[Object.keys(productResult?.addressResults || {})[0]]?.adjDimensions
                    };
                    
                    const codeCell = document.getElementById(`code-${productResult.productId}`);
                    const costCell = document.getElementById(`cost-${productResult.productId}`);
                    const carrierCell = document.getElementById(`carrier-${productResult.productId}`);
                    const lengthCell = document.getElementById(`length-${productResult.productId}`);
                    const heightCell = document.getElementById(`height-${productResult.productId}`);
                    const widthCell = document.getElementById(`width-${productResult.productId}`);
                    
                    if (codeCell) codeCell.innerText = suggestedCode >= 0 ? suggestedCode : '-';
                    
                    // Debug: Log what we received
                    console.log(`[DEBUG] Full product result for ${productResult.title}:`, productResult);
                    if (productResult.addressResults) {
                        console.log(`[DEBUG] Address results for ${productResult.title}:`, productResult.addressResults);
                        console.log(`[DEBUG] Address results keys:`, Object.keys(productResult.addressResults));
                    } else {
                        console.log(`[DEBUG] No addressResults property found in result`);
                    }
                    
                    if (productResult.addressResults && Object.keys(productResult.addressResults).length > 0) {
                        const addrResults = Object.values(productResult.addressResults);
                        const addrKeys = Object.keys(productResult.addressResults);
                        
                        if (addrResults.length === 1) {
                            const r = addrResults[0];
                            if (costCell) {
                                const cheapPrice = r.maxCheapPriceUSD ? '$' + r.maxCheapPriceUSD.toFixed(2) : '-';
                                const expressPrice = r.maxExpressPriceUSD ? ' / $' + r.maxExpressPriceUSD.toFixed(2) : '';
                                costCell.innerText = cheapPrice + expressPrice;
                            }
                            if (carrierCell) {
                                const cheapCarrier = r.cheapService || '-';
                                const expressCarrier = r.expressService ? ' / ' + r.expressService : '';
                                carrierCell.innerText = cheapCarrier + expressCarrier;
                            }
                        } else {
                            // Multiple addresses - show detailed breakdown
                            let costText = '';
                            let carrierText = '';
                            let tooltipText = '';
                            
                            addrKeys.forEach((addrId, idx) => {
                                const r = addrResults[idx];
                                const addr = addresses.find(a => a.id === addrId);
                                const addrLabel = addr ? `${addr.country}${addr.province ? `, ${addr.province}` : ''}` : `Location ${idx + 1}`;
                                
                                const cheapPrice = r.maxCheapPriceUSD ? '$' + r.maxCheapPriceUSD.toFixed(2) : 'N/A';
                                const expressPrice = r.maxExpressPriceUSD ? '$' + r.maxExpressPriceUSD.toFixed(2) : 'N/A';
                                const cheapCarrier = r.cheapService || 'N/A';
                                const expressCarrier = r.expressService || 'N/A';
                                
                                tooltipText += `${addrLabel}:\n  Cheap: ${cheapPrice} (${cheapCarrier})\n  Express: ${expressPrice} (${expressCarrier})\n\n`;
                                
                                if (idx === 0) {
                                    // Show first location's rates as primary display
                                    costText = `${cheapPrice}${r.maxExpressPriceUSD ? ' / ' + expressPrice : ''}`;
                                    carrierText = `${cheapCarrier}${r.expressService ? ' / ' + expressCarrier : ''}`;
                                }
                            });
                            
                            // Show range summary
                            const cheapPrices = addrResults.map(r => r.maxCheapPriceUSD || 0).filter(p => p > 0);
                            const expressPrices = addrResults.map(r => r.maxExpressPriceUSD || 0).filter(p => p > 0);
                            
                            if (costCell) {
                                if (cheapPrices.length > 0) {
                                    const cheapRange = `$${Math.min(...cheapPrices).toFixed(2)}-$${Math.max(...cheapPrices).toFixed(2)}`;
                                    const expressRange = expressPrices.length > 0 ? ` / $${Math.min(...expressPrices).toFixed(2)}-$${Math.max(...expressPrices).toFixed(2)}` : '';
                                    costCell.innerText = cheapRange + expressRange;
                                    costCell.title = tooltipText.trim();
                                    costCell.style.cursor = 'help';
                                } else {
                                    costCell.innerText = '-';
                                }
                            }
                            if (carrierCell) {
                                carrierCell.innerText = `${addrResults.length} locations`;
                                carrierCell.title = tooltipText.trim();
                                carrierCell.style.cursor = 'help';
                            }
                        }
                    } else {
                        // No address results - clear the cells
                        log(`‚ö†Ô∏è No address results found for ${productResult.title} - check backend response`);
                        if (costCell) costCell.innerText = '-';
                        if (carrierCell) carrierCell.innerText = '-';
                    }
                    
                    if (calculatedData[productResult.productId].adjDimensions) {
                        if (lengthCell) lengthCell.innerText = calculatedData[productResult.productId].adjDimensions.length + ' cm';
                        if (heightCell) heightCell.innerText = calculatedData[productResult.productId].adjDimensions.height + ' cm';
                        if (widthCell) widthCell.innerText = calculatedData[productResult.productId].adjDimensions.width + ' cm';
                    }
                    
                    // Note: Codes are NOT assigned during calculation - they will be assigned later via "Assign Code" button
                    const finalSuggestedCode = productResult?.suggestedCode ?? -1;
                    if (finalSuggestedCode >= 0) {
                        log(`üìä Code ${finalSuggestedCode} assigned (based on max price across all locations)`);
                    } else {
                        log(`üìä Calculation complete. Codes will be assigned when you click "Assign Code" button.`);
                    }
                    
                    // Update the table to show the "Show Rates" button if address results exist
                    if (productResult.addressResults && Object.keys(productResult.addressResults).length > 0) {
                        updateProductRowWithRates(productResult.productId);
                    }
                } else {
                    log(`‚ùå No results returned for product`);
                }
            } catch (e) {
                log(`‚ùå Calculation error: ${e.message}`);
            }
        }

        async function syncSelected() {
            const ids = getSelectedIds();
            const updates = [];
            
            ids.forEach(id => {
                const data = calculatedData[id];
                if (data && data.suggestedCode !== undefined && data.suggestedCode >= 0) {
                    updates.push({ 
                        productId: id, 
                        weight: data.suggestedWeight, // Code value (e.g., 15 = 15.00 kg)
                        codeIndex: data.suggestedCode, // The code index
                        rawWeight: data.rawWeight || data.suggestedWeight // Original weight before code
                    });
                }
            });
            
            if (updates.length === 0) return alert("No calculated data for selected products. Please calculate shipping first.");
            
            log(`Syncing ${updates.length} products to Shopify (setting weight to code value)...`);
            
            try {
                const response = await fetch('/api/shipping/sync', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ updates, shop: SHOP_DOMAIN })
                });
                
                const result = await response.json();
                if (result.success) {
                    log(`‚úÖ Synced ${result.updatedCount} products. Weight set to code value, metafields updated.`);
                    if(result.errors && result.errors.length > 0) {
                        log(`‚ö†Ô∏è Errors: ${JSON.stringify(result.errors)}`);
                    }
                } else {
                    log(`‚ùå Sync failed: ${result.error || 'Unknown error'}`);
                }
            } catch (e) {
                log("‚ùå Sync error: " + e.message);
            }
        }

        // Tab switching
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            if (tabName === 'products') {
                document.getElementById('productsTab').classList.add('active');
                document.querySelector('.tab[onclick="switchTab(\'products\')"]').classList.add('active');
            } else if (tabName === 'rates') {
                document.getElementById('ratesTab').classList.add('active');
                document.querySelector('.tab[onclick="switchTab(\'rates\')"]').classList.add('active');
                loadShippingRates();
            }
        }

        // Assign codes to all products with calculated rates
        async function assignCodes() {
            if (!confirm('Assign unique codes to all products with calculated shipping rates?')) {
                return;
            }

            const btn = event?.target || document.querySelector('button[onclick="assignCodes()"]');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = '‚è≥ Assigning codes...';

            try {
                log('üî¢ Starting code assignment...');
                const response = await fetch(`/api/shipping/assign-codes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ shop: SHOP_DOMAIN })
                });

                const data = await response.json();
                if (data.success) {
                    log(`‚úÖ Code assignment complete!`);
                    log(`   - Products processed: ${data.assignedCount}`);
                    log(`   - Shipping rate combinations: ${data.totalRatesAssigned}`);
                    log(`   - Unique codes generated: ${data.uniqueCodesGenerated}`);
                    if (data.errors && data.errors.length > 0) {
                        log(`   - Errors: ${data.errors.length}`);
                        data.errors.forEach(err => {
                            log(`     ‚ö†Ô∏è ${err.title}: ${err.error}`);
                        });
                    }
                    alert(`‚úÖ Codes assigned successfully!\n\nProducts: ${data.assignedCount}\nRate combinations: ${data.totalRatesAssigned}\nUnique codes: ${data.uniqueCodesGenerated}`);
                    // Refresh rates table if on that tab
                    if (document.getElementById('ratesTab').classList.contains('active')) {
                        loadShippingRates();
                    }
                } else {
                    throw new Error(data.error || 'Failed to assign codes');
                }
            } catch (error) {
                log(`‚ùå Error assigning codes: ${error.message}`);
                alert(`‚ùå Failed to assign codes: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.innerText = originalText;
            }
        }

        // Recalculate only failed/incomplete shipping rates
        async function recalculateFailedRates() {
            if (!confirm('Recalculate only failed shipping rates?\n\nThis will only process rates that have codes but are missing service/price data. Much faster than recalculating everything!')) {
                return;
            }

            const btn = event?.target || document.querySelector('button[onclick="recalculateFailedRates()"]');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = '‚è≥ Recalculating failed rates...';

            try {
                log('üîÑ Starting recalculation of failed rates...');
                const response = await fetch(`/api/shipping/recalculate-failed`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ shop: SHOP_DOMAIN })
                });

                const data = await response.json();
                if (data.success) {
                    if (data.status === 'processing') {
                        // Background processing started
                        log(`‚úÖ Recalculation started in background!`);
                        log(`   - Checking ${data.productsToCheck} products for failed rates...`);
                        log(`   - This will take several minutes. Check server logs for progress.`);
                        log(`   - You can refresh the page later to see updated rates.`);
                        alert(`‚úÖ Recalculation started!\n\nProcessing ${data.productsToCheck} products in the background.\n\nThis will take several minutes. Check the server logs for progress, or refresh the page later to see updated rates.`);
                        btn.disabled = false;
                        btn.innerText = '‚è≥ Processing in background...';
                        // Re-enable button after 30 seconds
                        setTimeout(() => {
                            btn.disabled = false;
                            btn.innerText = originalText;
                        }, 30000);
                    } else {
                        // Completed (shouldn't happen with new async approach, but keep for compatibility)
                        log(`‚úÖ Recalculation complete!`);
                        log(`   - Failed rates found: ${data.totalFailedRates || 0}`);
                        log(`   - Rates recalculated: ${data.totalRecalculated || 0}`);
                        if (data.errors && data.errors.length > 0) {
                            log(`   - Errors: ${data.errors.length}`);
                            data.errors.slice(0, 10).forEach(err => {
                                log(`     ‚ö†Ô∏è ${err.title} (${err.location}): ${err.error}`);
                            });
                            if (data.errors.length > 10) {
                                log(`     ... and ${data.errors.length - 10} more errors`);
                            }
                        }
                        alert(`‚úÖ Recalculation complete!\n\nFailed rates found: ${data.totalFailedRates || 0}\nRates recalculated: ${data.totalRecalculated || 0}\n\n${data.message || ''}`);
                        // Refresh products and rates tables
                        loadProducts();
                        if (document.getElementById('ratesTab').classList.contains('active')) {
                            loadShippingRates();
                        }
                        btn.disabled = false;
                        btn.innerText = originalText;
                    }
                } else {
                    throw new Error(data.error || 'Failed to recalculate failed rates');
                }
            } catch (error) {
                log(`‚ùå Error recalculating failed rates: ${error.message}`);
                alert(`‚ùå Failed to recalculate failed rates: ${error.message}`);
                btn.disabled = false;
                btn.innerText = originalText;
            }
        }

        // Carrier Calculated Shipping Functions
        async function checkCarrierServiceStatus() {
            const statusText = document.getElementById('carrierServiceStatusText');
            const registerBtn = document.getElementById('registerCarrierBtn');
            const unregisterBtn = document.getElementById('unregisterCarrierBtn');
            
            statusText.textContent = '‚è≥ Checking...';
            statusText.style.color = '#666';
            
            try {
                const carrierResponse = await fetch(`/api/shipping/carrier-service-status?shop=${SHOP_DOMAIN}`);
                const carrierData = await carrierResponse.json();
                
                if (carrierData.registered) {
                    statusText.textContent = `‚úÖ Enabled (ID: ${carrierData.carrierServiceId})`;
                    statusText.style.color = '#28a745';
                    registerBtn.style.display = 'none';
                    unregisterBtn.style.display = 'inline-block';
                    
                    if (carrierData.carrierService) {
                        log(`‚úÖ Carrier service found: ${carrierData.carrierService.name}`);
                        log(`   Callback URL: ${carrierData.carrierService.callback_url}`);
                        log(`   Format: ${carrierData.carrierService.format}`);
                    }
                    
                    // Show info about enabling in Shopify settings
                    if (carrierData.allServices && carrierData.allServices.length > 0) {
                        log(`üìã Found ${carrierData.allServices.length} carrier service(s) in Shopify`);
                    }
                } else {
                    statusText.textContent = '‚ùå Not Enabled';
                    statusText.style.color = '#dc3545';
                    registerBtn.style.display = 'inline-block';
                    unregisterBtn.style.display = 'none';
                    
                    if (carrierData.message) {
                        log(`‚ÑπÔ∏è ${carrierData.message}`);
                    }
                    if (carrierData.allServices && carrierData.allServices.length > 0) {
                        log(`üìã Found ${carrierData.allServices.length} other carrier service(s) in Shopify`);
                    }
                }
            } catch (error) {
                log(`‚ùå Error checking carrier service status: ${error.message}`);
                statusText.textContent = '‚ùå Error checking status';
                statusText.style.color = '#dc3545';
                registerBtn.style.display = 'inline-block';
                unregisterBtn.style.display = 'none';
            }
        }

        async function registerCarrierService() {
            if (!confirm('Register BuckyDrop as a Carrier Calculated Shipping service?\n\nThis will enable BuckyDrop rates to show automatically at checkout.\n\nRequires Shopify Grow plan or higher.')) {
                return;
            }

            const btn = document.getElementById('registerCarrierBtn');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = '‚è≥ Registering...';

            try {
                log('üöö Registering carrier service...');
                const response = await fetch(`/api/shipping/register-carrier-service`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ shop: SHOP_DOMAIN })
                });

                const data = await response.json();
                if (data.success) {
                    log(`‚úÖ Carrier service registered successfully!`);
                    log(`   Service ID: ${data.carrierService.id}`);
                    log(`   Name: ${data.carrierService.name}`);
                    log(`   Callback URL: ${data.carrierService.callback_url}`);
                    
                    let message = `‚úÖ Carrier service registered!\n\n`;
                    message += `Service ID: ${data.carrierService.id}\n`;
                    message += `Name: ${data.carrierService.name}\n\n`;
                    message += `‚ö†Ô∏è IMPORTANT: You must enable this carrier service in Shopify:\n`;
                    message += `1. Go to Settings > Shipping and delivery\n`;
                    message += `2. Click "Manage rates" for your shipping zone\n`;
                    message += `3. Enable "BuckyDrop Shipping" in the carrier list\n`;
                    message += `4. Save your changes\n\n`;
                    message += `After enabling, BuckyDrop rates will show at checkout.`;
                    
                    alert(message);
                    checkCarrierServiceStatus();
                } else {
                    throw new Error(data.error || 'Failed to register carrier service');
                }
            } catch (error) {
                log(`‚ùå Error registering carrier service: ${error.message}`);
                alert(`‚ùå Failed to register carrier service: ${error.message}\n\nMake sure:\n- You have Shopify Grow plan or higher\n- Carrier Calculated Shipping is enabled in your Shopify settings\n- Your app has the required permissions`);
            } finally {
                btn.disabled = false;
                btn.innerText = originalText;
            }
        }

        async function listCarrierServices() {
            try {
                log('üîç Listing all carrier services from Shopify...');
                const response = await fetch(`/api/shipping/list-carrier-services?shop=${SHOP_DOMAIN}`);
                const data = await response.json();
                
                if (data.success) {
                    log(`üìã Found ${data.count} carrier service(s) in Shopify:`);
                    data.carrierServices.forEach((cs, index) => {
                        log(`   ${index + 1}. ${cs.name} (ID: ${cs.id})`);
                        log(`      Callback: ${cs.callback_url || 'N/A'}`);
                        log(`      Format: ${cs.format || 'N/A'}`);
                        log(`      Active: ${cs.active !== false ? 'Yes' : 'No'}`);
                    });
                    
                    if (data.buckyDropFound) {
                        log(`‚úÖ BuckyDrop Shipping is registered!`);
                    } else {
                        log(`‚ùå BuckyDrop Shipping NOT found in the list`);
                        log(`   This means it wasn't registered successfully.`);
                        log(`   Try clicking "Enable Carrier Service" again and check for errors.`);
                    }
                    
                    alert(`Found ${data.count} carrier service(s)\n\n${data.carrierServices.map(cs => `‚Ä¢ ${cs.name}`).join('\n')}\n\n${data.buckyDropFound ? '‚úÖ BuckyDrop is registered' : '‚ùå BuckyDrop NOT found - registration may have failed'}`);
                } else {
                    throw new Error(data.error || 'Failed to list carrier services');
                }
            } catch (error) {
                log(`‚ùå Error listing carrier services: ${error.message}`);
                alert(`‚ùå Failed to list carrier services: ${error.message}`);
            }
        }

        async function unregisterCarrierService() {
            if (!confirm('Unregister the carrier service?\n\nBuckyDrop rates will no longer show at checkout.')) {
                return;
            }

            const btn = document.getElementById('unregisterCarrierBtn');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = '‚è≥ Unregistering...';

            try {
                log('üöö Unregistering carrier service...');
                const response = await fetch(`/api/shipping/unregister-carrier-service?shop=${SHOP_DOMAIN}`, {
                    method: 'DELETE'
                });

                const data = await response.json();
                if (data.success) {
                    log(`‚úÖ Carrier service unregistered successfully!`);
                    alert(`‚úÖ Carrier service unregistered!\n\nBuckyDrop rates will no longer show at checkout.`);
                    checkCarrierServiceStatus();
                } else {
                    throw new Error(data.error || 'Failed to unregister carrier service');
                }
            } catch (error) {
                log(`‚ùå Error unregistering carrier service: ${error.message}`);
                alert(`‚ùå Failed to unregister carrier service: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.innerText = originalText;
            }
        }

        // Update weights in Shopify
        async function updateWeights() {
            if (!confirm('Update product weights in Shopify to match assigned codes?\n\nCode N = N kg')) {
                return;
            }

            const btn = event?.target || document.querySelector('button[onclick="updateWeights()"]');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = '‚è≥ Updating weights...';

            try {
                log('‚öñÔ∏è Starting weight update...');
                const response = await fetch(`/api/shipping/update-weights`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ shop: SHOP_DOMAIN })
                });

                const data = await response.json();
                if (data.success) {
                    log(`‚úÖ Weight update complete!`);
                    log(`   - Products updated: ${data.updatedCount}`);
                    if (data.errors && data.errors.length > 0) {
                        log(`   - Errors: ${data.errors.length}`);
                        data.errors.forEach(err => {
                            log(`     ‚ö†Ô∏è ${err.title}: ${err.error}`);
                        });
                    }
                    alert(`‚úÖ Weights updated successfully!\n\nProducts updated: ${data.updatedCount}`);
                    // Reload products to show updated weights
                    loadProducts();
                } else {
                    throw new Error(data.error || 'Failed to update weights');
                }
            } catch (error) {
                log(`‚ùå Error updating weights: ${error.message}`);
                alert(`‚ùå Failed to update weights: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.innerText = originalText;
            }
        }

        // Unprocess selected products (remove processed status)
        async function unprocessSelected() {
            const ids = getSelectedIds();
            if (ids.length === 0) {
                alert('Please select at least one product to unprocess.');
                return;
            }

            if (!confirm(`Unprocess ${ids.length} selected product(s)?\n\nThis will:\n- Remove "Processed" status\n- Clear shipping rates\n- Products will be ready for recalculation`)) {
                return;
            }

            const btn = event?.target || document.querySelector('button[onclick="unprocessSelected()"]');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = '‚è≥ Unprocessing...';

            try {
                log(`‚Ü©Ô∏è Unprocessing ${ids.length} products...`);
                const response = await fetch(`/api/shipping/unprocess`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        shop: SHOP_DOMAIN,
                        productIds: ids
                    })
                });

                const data = await response.json();
                if (data.success) {
                    log(`‚úÖ Unprocessed ${data.unprocessedCount} products`);
                    alert(`‚úÖ Successfully unprocessed ${data.unprocessedCount} product(s)`);
                    // Reload products to show updated status
                    loadProducts();
                    // Clear calculated data for unprocessed products
                    ids.forEach(id => {
                        delete calculatedData[id];
                        delete addressResults[id];
                    });
                } else {
                    throw new Error(data.error || 'Failed to unprocess products');
                }
            } catch (error) {
                log(`‚ùå Error unprocessing products: ${error.message}`);
                alert(`‚ùå Failed to unprocess products: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.innerText = originalText;
            }
        }

        // Delete shipping rates for selected products
        async function deleteRatesSelected() {
            const ids = getSelectedIds();
            if (ids.length === 0) {
                alert('Please select at least one product to delete shipping rates.');
                return;
            }

            if (!confirm(`Delete shipping rates for ${ids.length} selected product(s)?\n\nThis will:\n- Remove all shipping rate calculations\n- Remove "Processed" status\n- Products will be ready for recalculation\n\n‚ö†Ô∏è This action cannot be undone!`)) {
                return;
            }

            const btn = event?.target || document.querySelector('button[onclick="deleteRatesSelected()"]');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = '‚è≥ Deleting rates...';

            try {
                log(`üóëÔ∏è Deleting shipping rates for ${ids.length} products...`);
                const response = await fetch(`/api/shipping/delete-rates`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        shop: SHOP_DOMAIN,
                        productIds: ids
                    })
                });

                const data = await response.json();
                if (data.success) {
                    log(`‚úÖ Deleted shipping rates for ${data.deletedCount} products`);
                    alert(`‚úÖ Successfully deleted shipping rates for ${data.deletedCount} product(s)`);
                    // Reload products to show updated status
                    loadProducts();
                    // Clear calculated data for products
                    ids.forEach(id => {
                        delete calculatedData[id];
                        delete addressResults[id];
                    });
                    // Refresh rates table if on that tab
                    if (document.getElementById('ratesTab').classList.contains('active')) {
                        loadShippingRates();
                    }
                } else {
                    throw new Error(data.error || 'Failed to delete shipping rates');
                }
            } catch (error) {
                log(`‚ùå Error deleting shipping rates: ${error.message}`);
                alert(`‚ùå Failed to delete shipping rates: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.innerText = originalText;
            }
        }

        // Load shipping rates table (with filtering, sorting, and search)
        let allRatesData = []; // Store all data for filtering/sorting
        let filteredRatesData = []; // Currently displayed data
        let currentRatesSort = { column: null, direction: 'asc' };
        
        async function loadShippingRates() {
            const tbody = document.getElementById('ratesTableBody');
            const table = document.getElementById('ratesTable');
            const empty = document.getElementById('ratesEmpty');
            const stats = document.getElementById('ratesStats');

            tbody.innerHTML = '<tr><td colspan="7" style="text-align:center">Loading...</td></tr>';
            table.style.display = 'none';
            empty.style.display = 'none';

            try {
                const response = await fetch(`/api/shipping/rates?shop=${SHOP_DOMAIN}&export=true`);
                const data = await response.json();

                if (data.success && data.data && data.data.length > 0) {
                    allRatesData = data.data;
                    
                    // Populate country filter dropdown
                    const countryFilter = document.getElementById('ratesCountryFilter');
                    const countries = [...new Set(allRatesData.map(r => r.country).filter(Boolean))].sort();
                    countryFilter.innerHTML = '<option value="">All Countries</option>';
                    countries.forEach(country => {
                        const option = document.createElement('option');
                        option.value = country;
                        option.textContent = country;
                        countryFilter.appendChild(option);
                    });
                    
                    // Apply filters and render
                    filterRatesTable();
                } else {
                    tbody.innerHTML = '';
                    stats.innerText = 'No shipping rates found';
                    table.style.display = 'none';
                    empty.style.display = 'block';
                }
            } catch (error) {
                log(`‚ùå Error loading shipping rates: ${error.message}`);
                tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; color: red;">Error loading rates</td></tr>';
                stats.innerText = 'Error loading rates';
            }
        }
        
        function filterRatesTable() {
            const searchTerm = (document.getElementById('ratesSearch')?.value || '').toLowerCase();
            const countryFilter = document.getElementById('ratesCountryFilter')?.value || '';
            const codeFilter = (document.getElementById('ratesCodeFilter')?.value || '').trim();
            const serviceFilter = document.getElementById('ratesServiceFilter')?.value || '';
            
            filteredRatesData = allRatesData.filter(rate => {
                // Search filter
                if (searchTerm) {
                    const searchable = [
                        rate.country || '',
                        rate.province || '',
                        rate.postcode || '',
                        rate.standardService || '',
                        rate.expressService || '',
                        rate.uniqueCode || ''
                    ].join(' ').toLowerCase();
                    if (!searchable.includes(searchTerm)) {
                        return false;
                    }
                }
                
                // Country filter
                if (countryFilter && rate.country !== countryFilter) {
                    return false;
                }
                
                // Code filter
                if (codeFilter && rate.uniqueCode !== codeFilter) {
                    return false;
                }
                
                // Service filter
                if (serviceFilter === 'standard' && !rate.standardService) {
                    return false;
                }
                if (serviceFilter === 'express' && !rate.expressService) {
                    return false;
                }
                if (serviceFilter === 'both' && (!rate.standardService || !rate.expressService)) {
                    return false;
                }
                
                return true;
            });
            
            // Apply sorting if active
            if (currentRatesSort.column) {
                sortRatesTable(currentRatesSort.column, false);
            } else {
                renderRatesTable();
            }
        }
        
        function sortRatesTable(column, toggle = true) {
            const tbody = document.getElementById('ratesTableBody');
            const stats = document.getElementById('ratesStats');
            
            // Toggle direction if clicking same column
            if (toggle && currentRatesSort.column === column) {
                currentRatesSort.direction = currentRatesSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentRatesSort.column = column;
                currentRatesSort.direction = 'asc';
            }
            
            // Clear all sort indicators
            document.querySelectorAll('#ratesTable .sort-indicator').forEach(ind => {
                ind.className = 'sort-indicator';
            });
            
            // Set active sort indicator
            const indicator = document.getElementById(`sort-${column}`);
            if (indicator) {
                indicator.className = `sort-indicator ${currentRatesSort.direction}`;
            }
            
            // Sort data
            filteredRatesData.sort((a, b) => {
                let aVal, bVal;
                
                switch(column) {
                    case 'country':
                        aVal = (a.country || '').toLowerCase();
                        bVal = (b.country || '').toLowerCase();
                        break;
                    case 'province':
                        aVal = (a.province || '').toLowerCase();
                        bVal = (b.province || '').toLowerCase();
                        break;
                    case 'postcode':
                        aVal = (a.postcode || '').toLowerCase();
                        bVal = (b.postcode || '').toLowerCase();
                        break;
                    case 'service':
                        aVal = ((a.standardService || '') + ' ' + (a.expressService || '')).toLowerCase();
                        bVal = ((b.standardService || '') + ' ' + (b.expressService || '')).toLowerCase();
                        break;
                    case 'days':
                        aVal = (a.standardMinDays || 0) + (a.expressMinDays || 0);
                        bVal = (b.standardMinDays || 0) + (b.expressMinDays || 0);
                        break;
                    case 'price':
                        aVal = (a.standardPrice || 0) + (a.expressPrice || 0);
                        bVal = (b.standardPrice || 0) + (b.expressPrice || 0);
                        break;
                    case 'code':
                        aVal = Number(a.uniqueCode) || 0;
                        bVal = Number(b.uniqueCode) || 0;
                        break;
                    default:
                        return 0;
                }
                
                if (typeof aVal === 'string') {
                    return currentRatesSort.direction === 'asc' 
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                } else {
                    return currentRatesSort.direction === 'asc' 
                        ? aVal - bVal
                        : bVal - aVal;
                }
            });
            
            renderRatesTable();
        }
        
        function renderRatesTable() {
            const tbody = document.getElementById('ratesTableBody');
            const table = document.getElementById('ratesTable');
            const empty = document.getElementById('ratesEmpty');
            const stats = document.getElementById('ratesStats');
            
            tbody.innerHTML = '';
            
            if (filteredRatesData.length === 0) {
                table.style.display = 'none';
                empty.style.display = 'block';
                stats.innerText = 'No shipping rates match your filters';
                return;
            }
            
            filteredRatesData.forEach(rate => {
                try {
                    const row = tbody.insertRow();
                    
                    // Country
                    const countryCell = row.insertCell();
                    countryCell.innerText = rate.country || '-';
                    countryCell.style.padding = '10px';
                    
                    // Province
                    const provinceCell = row.insertCell();
                    provinceCell.innerText = rate.province || '-';
                    provinceCell.style.padding = '10px';
                    
                    // Postcode
                    const postcodeCell = row.insertCell();
                    postcodeCell.innerText = rate.postcode || '-';
                    postcodeCell.style.padding = '10px';
                    
                    // Service
                    const serviceCell = row.insertCell();
                    const standardService = rate.standardService || '-';
                    const expressService = rate.expressService || '-';
                    serviceCell.innerHTML = `<div style="font-size: 12px;"><strong>Standard:</strong> ${standardService}</div><div style="font-size: 12px; color: #666;"><strong>Express:</strong> ${expressService}</div>`;
                    serviceCell.style.padding = '10px';
                    
                    // Days
                    const daysCell = row.insertCell();
                    const standardDays = rate.standardMinDays && rate.standardMaxDays 
                        ? `${rate.standardMinDays}-${rate.standardMaxDays}` 
                        : (rate.standardMinDays || rate.standardMaxDays || '-');
                    const expressDays = rate.expressMinDays && rate.expressMaxDays 
                        ? `${rate.expressMinDays}-${rate.expressMaxDays}` 
                        : (rate.expressMinDays || rate.expressMaxDays || '-');
                    daysCell.innerHTML = `<div style="font-size: 12px;">${standardDays}</div><div style="font-size: 12px; color: #666;">${expressDays}</div>`;
                    daysCell.style.padding = '10px';
                    
                    // Price
                    const priceCell = row.insertCell();
                    const standardPrice = rate.standardPrice ? '$' + Number(rate.standardPrice).toFixed(2) : '-';
                    const expressPrice = rate.expressPrice ? '$' + Number(rate.expressPrice).toFixed(2) : '-';
                    priceCell.innerHTML = `<div style="font-size: 12px;"><strong>${standardPrice}</strong></div><div style="font-size: 12px; color: #666;">${expressPrice}</div>`;
                    priceCell.style.padding = '10px';
                    
                    // Code
                    const codeCell = row.insertCell();
                    codeCell.innerText = rate.uniqueCode || '-';
                    codeCell.style.padding = '10px';
                    codeCell.style.fontWeight = '600';
                    if (!rate.uniqueCode) {
                        codeCell.style.color = '#999';
                        codeCell.style.fontStyle = 'italic';
                    }
                } catch (err) {
                    console.error('Error rendering rate row:', err, rate);
                }
            });
            
            table.style.display = 'table';
            empty.style.display = 'none';
            stats.innerHTML = `Showing <strong>${filteredRatesData.length}</strong> of <strong>${allRatesData.length}</strong> shipping rate entries`;
        }

        // Export to CSV - COMPLETELY REBUILT
        async function exportToCSV() {
            try {
                log('üì• Fetching all shipping rates for CSV export...');
                const response = await fetch(`/api/shipping/rates?shop=${SHOP_DOMAIN}&export=true`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();

                if (!data.success || !data.data || data.data.length === 0) {
                    alert('No shipping rates data to export.');
                    return;
                }

                // Debug: Log actual data structure
                console.log('üìä API Response:', {
                    totalRows: data.data.length,
                    sampleRow: data.data[0],
                    allCodes: data.data.map(r => r.uniqueCode || r.uniqueCodes).filter((v, i, a) => a.indexOf(v) === i).slice(0, 50),
                    codesByCountry: (() => {
                        const byCountry = {};
                        data.data.forEach(r => {
                            const code = r.uniqueCode || r.uniqueCodes;
                            if (!byCountry[r.country]) byCountry[r.country] = new Set();
                            byCountry[r.country].add(code);
                        });
                        return Object.keys(byCountry).map(c => ({
                            country: c,
                            codes: Array.from(byCountry[c]).sort()
                        }));
                    })()
                });

                log(`üìä Exporting ${data.data.length} shipping rate entries to CSV...`);

                // Helper: Convert calendar days to business days
                function toBusinessDays(calDays) {
                    if (calDays === null || calDays === undefined || calDays === '') return null;
                    const numDays = Number(calDays);
                    if (isNaN(numDays) || numDays <= 0) return null;
                    const weeks = Math.floor(numDays / 7);
                    const remainder = numDays % 7;
                    return (weeks * 5) + Math.min(remainder, 5);
                }

                function formatBusinessDays(minDays, maxDays) {
                    const minBiz = toBusinessDays(minDays);
                    const maxBiz = toBusinessDays(maxDays);
                    
                    if (minBiz !== null && maxBiz !== null) {
                        if (minBiz === maxBiz) {
                            return `${minBiz} business days`;
                        }
                        return `${minBiz}-${maxBiz} business days`;
                    } else if (minBiz !== null) {
                        return `${minBiz} business days`;
                    } else if (maxBiz !== null) {
                        return `${maxBiz} business days`;
                    }
                    return '';
                }

                // Helper: Format price (single max value) - with null safety
                function formatPrice(price) {
                    try {
                        if (price !== null && price !== undefined && price !== '' && !isNaN(price)) {
                            const priceNum = Number(price);
                            if (priceNum > 0) {
                                return priceNum.toFixed(2);
                            }
                        }
                        return '';
                    } catch (err) {
                        console.warn('Price formatting error:', err, { price });
                        return '';
                    }
                }

                // Helper: Escape CSV value - use formula format for codes to prevent Excel date formatting
                function escapeCSV(value, isCodeColumn = false) {
                    let text = String(value || '').trim();
                    
                    // For code column, use Excel formula format: ="value" to force text interpretation
                    if (isCodeColumn && text !== '') {
                        // Use formula format to prevent Excel from interpreting as date
                        text = `="${text}"`;
                    }
                    
                    // If already wrapped in quotes (formula), don't double-wrap
                    if (text.startsWith('=') && text.includes('"')) {
                        return text;
                    }
                    
                    // Otherwise, escape normally
                    if (text.includes(',') || text.includes('"') || text.includes('\n')) {
                        return '"' + text.replace(/"/g, '""') + '"';
                    }
                    return text;
                }

                // CSV headers
                const headers = [
                    'Country',
                    'Province',
                    'Postcode',
                    'Standard/Economy Service',
                    'Standard/Economy Price (USD)',
                    'Standard/Economy Days (Business)',
                    'Express Service',
                    'Express Price (USD)',
                    'Express Days (Business)',
                    'Unique Code'
                ];

                // Build CSV
                let csv = headers.map(h => escapeCSV(h)).join(',') + '\n';

                data.data.forEach((rate, index) => {
                    try {
                        const standardPrice = formatPrice(rate.standardPrice);
                        const expressPrice = formatPrice(rate.expressPrice);
                        const standardDays = formatBusinessDays(rate.standardMinDays, rate.standardMaxDays);
                        const expressDays = formatBusinessDays(rate.expressMinDays, rate.expressMaxDays);
                        
                        const row = [
                            rate.country || '',
                            rate.province || '',
                            rate.postcode || '',
                            rate.standardService || '',
                            standardPrice,
                            standardDays,
                            rate.expressService || '',
                            expressPrice,
                            expressDays,
                            rate.uniqueCode || rate.uniqueCodes || '' // Code is already a string from API
                        ];

                        // Escape each value, with special handling for code column (last column, index 9)
                        const escapedRow = row.map((val, idx) => escapeCSV(val, idx === 9));
                        csv += escapedRow.join(',') + '\n';
                    } catch (err) {
                        console.error(`Error processing row ${index}:`, err, rate);
                        log(`‚ö†Ô∏è Error processing row ${index}: ${err.message}`);
                    }
                });

                // Download CSV
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `shipping_rates_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                log(`‚úÖ CSV exported successfully: ${data.data.length} rows`);
            } catch (error) {
                console.error('CSV export error:', error);
                log(`‚ùå Error exporting CSV: ${error.message}`);
                alert(`Error exporting CSV: ${error.message}`);
            }
        }

        // Init
        // Clear any active polling intervals from previous sessions
        if (window.shippingPollInterval) {
            clearInterval(window.shippingPollInterval);
            window.shippingPollInterval = null;
        }
        if (window.shippingVisibilityHandler) {
            document.removeEventListener('visibilitychange', window.shippingVisibilityHandler);
            window.shippingVisibilityHandler = null;
        }
        
        document.getElementById('shopName').innerText = SHOP_DOMAIN;
        // Load products with the current filter selection (defaults to 'all')
        const initialStatus = document.getElementById('statusFilter').value;
        const initialProcessed = document.getElementById('processedFilter').value;
        currentStatus = initialStatus;
        loadProducts(1, initialStatus, initialProcessed).catch(err => {
            console.error('Error loading products on init:', err);
            const tbody = document.getElementById('tableBody');
            if (tbody) {
                tbody.innerHTML = `<tr><td colspan="12" style="text-align:center; color: red; padding: 20px;">Error loading products: ${err.message}<br><br>Please refresh the page.</td></tr>`;
            }
        });
    </script>
</body>
</html>
